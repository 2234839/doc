<!DOCTYPE html>
    <html
      lang="zh_CN"
      data-theme-mode="light"
      data-light-theme="daylight"
      data-dark-theme="midnight"
    >
      <head>
        
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
        />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black" />
        <link
          rel="stylesheet"
          type="text/css"
          id="baseStyle"
          href="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/build/export/base.css?2.10.5"
        />
        <link
          rel="stylesheet"
          type="text/css"
          id="themeDefaultStyle"
          href="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/appearance/themes/daylight/theme.css?2.10.5"
        />

        <title>11月</title>
        <style>
          body {
            background-color: var(--b3-theme-background);
            color: var(--b3-theme-on-background);
          }
          .b3-typography,
          .protyle-wysiwyg,
          .protyle-title {
            font-size: 16px !important;
          }
          .b3-typography code:not(.hljs),
          .protyle-wysiwyg span[data-type~="code"] {
            font-variant-ligatures: normal;
          }
          .li > .protyle-action {
            height: 34px;
            line-height: 34px;
          }
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h1,
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h2,
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h3,
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h4,
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h5,
          .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h6 {
            line-height: 34px;
          }
          .protyle-wysiwyg [data-node-id].li > .protyle-action:after {
            height: 16px;
            width: 16px;
            margin: -8px 0 0 -8px;
          }
          .protyle-wysiwyg [data-node-id].li > .protyle-action svg {
            height: 14px;
          }
          .protyle-wysiwyg [data-node-id].li:before {
            height: calc(100% - 34px);
            top: 34px;
          }
          .protyle-wysiwyg [data-node-id] [spellcheck] {
            min-height: 26px;
          }
          .protyle-wysiwyg [data-node-id] {
          }
          .protyle-wysiwyg .li {
            min-height: 34px;
          }
          .protyle-gutters button svg {
            height: 26px;
          }
          .protyle-wysiwyg img.emoji,
          .b3-typography img.emoji {
            width: 18px;
          }
          .protyle-wysiwyg .h1 img.emoji,
          .b3-typography h1 img.emoji {
            width: 35px;
          }
          .protyle-wysiwyg .h2 img.emoji,
          .b3-typography h2 img.emoji {
            width: 31px;
          }
          .protyle-wysiwyg .h3 img.emoji,
          .b3-typography h3 img.emoji {
            width: 27px;
          }
          .protyle-wysiwyg .h4 img.emoji,
          .b3-typography h4 img.emoji {
            width: 25px;
          }
          .protyle-wysiwyg .h5 img.emoji,
          .b3-typography h5 img.emoji {
            width: 22px;
          }
          .protyle-wysiwyg .h6 img.emoji,
          .b3-typography h6 img.emoji {
            width: 20px;
          }
        </style>
      </head>
      <body>
        
        <div
          class="protyle-wysiwyg protyle-wysiwyg--attr"
          style="max-width: 800px;margin: 0 auto;"
          id="preview"
        >
          <div class="protyle-background protyle-background--enable" style="min-height: 150px;" id="20201105164945-ukz3aft" data-node-id="20201105164945-ukz3aft" data-type="NodeDocument" updated="20210818123045" data-subtype="h1" class="h1" title="11月" type="doc">
      <div class="protyle-background__img" style="margin-bottom: 30px;position: relative;height: 25vh;undefined"/>
      
</div>
<div id="20201121144434-yhcbzvf" data-node-id="20201121144434-yhcbzvf" data-type="NodeHeading" data-subtype="h1" class="h1">
      <div>
2020/11 
<span data-type="block-ref"     data-subtype="s"     data-id="20201113135205-ji8ofpq">
          <a href="">每日总结</a>
  </span>
</div>
    </div>
<div id="20210410111356-ho62xfm" data-node-id="20210410111356-ho62xfm" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-jwxv78h" data-node-id="20201121144434-jwxv78h" data-type="NodeParagraph" updated="20210623110447" class="p">今天（2020/11/5）将文档改成了基于
<span data-type="block-ref"     data-subtype="d"     data-id="20201104155455-awawq0n">
          <a href="./../../../record/思源笔记.html#20201104155455-awawq0n">思源笔记</a>
  </span>
实现的了，之后应该会提高在自己博客上写文章的频率了。
</div>
<div id="20210623110454-bbg77mg" data-node-id="20210623110454-bbg77mg" data-type="NodeParagraph" updated="20210623110454" class="p"></div>
<div id="20201121144434-tpx6zn9" data-node-id="20201121144434-tpx6zn9" data-type="NodeParagraph" class="p">之前都是在 我来 上写，毕竟那里的体验要好很多。但现在使用思源再实现双链之类的功能也很棒，虽然还比不上 我来 但终究还是很有必要在自己的平台输出的。
</div>
<div id="20201121144434-ye2cfcm" data-node-id="20201121144434-ye2cfcm" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
我的博客改为使用思源还有的一点小缺陷
</div>
    </div>
<div id="20201121144434-2tq5tsi" data-node-id="20201121144434-2tq5tsi" data-type="NodeList" data-subtype="t" class="list" data-marker="*"><div id="20201121144434-9irkdtl" data-node-id="20201121144434-9irkdtl" data-type="NodeListItem" data-subtype="t" class="li protyle-task--done " data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconCheck"></use></svg>
      </div>
      
<div id="20210410111356-cx203v3" data-node-id="20210410111356-cx203v3" data-type="NodeParagraph" class="p">​
<span data-type="s">引用其他块的渲染还没写好（2020/11/8 号解决了）</span>
</div>

    </div>
<div id="20201121144434-p6t3uhn" data-node-id="20201121144434-p6t3uhn" data-type="NodeListItem" data-subtype="t" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconUncheck"></use></svg>
      </div>
      
<div id="20210410111356-4kbarqg" data-node-id="20210410111356-4kbarqg" data-type="NodeParagraph" class="p">还有嵌入内容块的渲染需要实现
</div>

    </div>
</div>
<div id="20201121144434-o5upxof" data-node-id="20201121144434-o5upxof" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
加速度传感器与角速度传感器（陀螺仪）导致的窃听漏洞
</div>
    </div>
<div id="20201121144434-o7btsfj" data-node-id="20201121144434-o7btsfj" data-type="NodeParagraph" class="p">相关文章 https://www.leiphone.com/news/202002/rVLRlq5oqDFtIanl.html
</div>
<div id="20201121144434-7g4zpec" data-node-id="20201121144434-7g4zpec" data-type="NodeParagraph" class="p">现在最蛋疼的一点是在没有 root 的情况下好像没有办法禁用掉 app 对相关数据的获取。
</div>
<div id="20201121144434-xorbo7s" data-node-id="20201121144434-xorbo7s" data-type="NodeParagraph" class="p">根据 https://note.qidong.name/2018/03/hugo-mathjax/ 这篇文章给博客加上了 
<span data-type="inline-math" data-subtype="math" data-content="s = pi * r^2" class="render-node"></span>
 公式渲染的功能
</div>
<div id="20201121144434-1kerptv" data-node-id="20201121144434-1kerptv" data-type="NodeParagraph" class="p">lute 通过 
<span data-type="code">lute.SetHeadingAnchor(true);</span>
 可以配置渲染 h 系列的标签的时候加入一个 a 标签链接到该标题 效果如图 
<span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201106140132-bml2b50-image.png"
        data-src="./../../../assets/20201106140132-bml2b50-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201121144434-xau0huh" data-node-id="20201121144434-xau0huh" data-type="NodeParagraph" class="p">今天在使用 
<span data-type="code">const a ??= b</span>
 这种语法的时候遇到了一些问题首先是没有添加 
<span data-type="code">&quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;</span>
 插件。
</div>
<div id="20201121144434-puduug6" data-node-id="20201121144434-puduug6" data-type="NodeParagraph" class="p">但添加之后还是报错 
<span data-type="code">Syntax Error: SyntaxError: This experimental syntax requires enabling the parser plugin: 'nullishCoalescingOperator' (123:21)</span>
 这就很难受了， https://github.com/dcloudio/uni-app/issues/1660 这里有和我一样踩坑的人。但还没有找到合适的解决方案，只能在 uni-app 项目中先放弃使用该语法了
</div>
<div id="20201121144434-h1cvdcn" data-node-id="20201121144434-h1cvdcn" data-type="NodeHeading" updated="20210410111731" data-subtype="h2" class="h2">
      <div>
<a href="https://lihautan.com/pause-and-resume-a-javascript-function/">js 让一段实际上是异步的代码写起来像是同步的</a>
</div>
    </div>
<div id="20201121144434-v0idpya" data-node-id="20201121144434-v0idpya" data-type="NodeParagraph" class="p">这篇文章的主要思路其实就是 第一次 执行代码遇到异步点的时候执行异步函数然后 throw 中断下面的代码，然后拿到结果后再执行一次。
</div>
<div id="20201121144434-7k2f3q5" data-node-id="20201121144434-7k2f3q5" data-type="NodeParagraph" class="p">这个体验还是不太行的实现起来也太复杂
</div>
<div id="20201121144434-7lhc8ev" data-node-id="20201121144434-7lhc8ev" data-type="NodeParagraph" class="p">我在知乎提了一个问题 https://www.zhihu.com/question/429221892
</div>
<div id="20210410111807-d125j38" data-node-id="20210410111807-d125j38" data-type="NodeHeading" updated="20210410111821" data-subtype="h2" class="h2">
      <div>
<span data-type="block-ref"     data-subtype="d"     data-id="20201121144434-sbev4ga">
          <a href="./../../../读书笔记/typescript/一个简简单单的 TypeScript RPC 解决方案.html#20201121144434-sbev4ga">一个简简单单的 TypeScript RPC 解决方案</a>
  </span>
</div>
    </div>
<div id="20210410111738-ylkel4q" data-node-id="20210410111738-ylkel4q" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-xfjenrc" data-node-id="20201121144434-xfjenrc" data-type="NodeParagraph" updated="20210818123045" class="p"><span data-type="code">xml:base=&quot;https://shenzilong.cn/关于/赞助.html&quot;</span>
 这样的属性可以设置 XML 的 base 路径，今天给我的 
<a href="https://shenzilong.cn/blog/feed">feed</a>
 加上了这样的路径 ，但不知道是不是我使用的 rss 阅读器的问题，他好像还是没有办法正确识别。
</div>
<div id="20201121144434-boyf2r6" data-node-id="20201121144434-boyf2r6" data-type="NodeParagraph" updated="20210410111549" class="p">例如 
<span data-type="code">&lt;a href=&quot;#标题1&quot;&gt;</span>
  这样的路径他会识别为 
<span data-type="code">https://shenzilong.cn/关于/赞助#标题1</span>
  这样的路径。
</div>
<div id="20201121144434-zixchle" data-node-id="20201121144434-zixchle" data-type="NodeBlockquote" class="bq" parent-fold="1">
<div id="20201121144434-92gye3r" data-node-id="20201121144434-92gye3r" data-type="NodeParagraph" class="p">有时候不需要什么「分布式」，前后端「项目分离」。
</div>
<div id="20201121144434-7tekmdf" data-node-id="20201121144434-7tekmdf" data-type="NodeParagraph" class="p">只是想可以方便调用一个接口、不去写接口文档、还有有完善的方法类型提示而已。
</div>
<div id="20201121144434-72audfc" data-node-id="20201121144434-72audfc" data-type="NodeParagraph" class="p">何必那么复杂呢。......
</div>
<div id="20201121144434-vzyu84i" data-node-id="20201121144434-vzyu84i" data-type="NodeParagraph" class="p">这里提供超轻量级的远程调用，完备的类型提示！
</div>
</div>
<div id="20201121144434-10a6mik" data-node-id="20201121144434-10a6mik" data-type="NodeParagraph" class="p" parent-fold="1"><a href="https://codesandbox.io/s/github/2234839/typescript_RPC_demo?utm_medium=plugin&file=/src/rpc.ts">codesandbox 体验地址</a>
 codesandbox 的类型提示还不太行，本地开发是没有问题的
</div>
<div id="20201121144434-z7z0r3p" data-node-id="20201121144434-z7z0r3p" data-type="NodeParagraph" class="p" parent-fold="1"><a href="https://github.com/2234839/typescript_RPC_demo">demo  github 地址</a>
</div>
<div id="20201121144434-ulxsxqf" data-node-id="20201121144434-ulxsxqf" data-type="NodeParagraph" class="p" parent-fold="1"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201109143728-hfw4r7v-image.png"
        data-src="./../../../assets/20201109143728-hfw4r7v-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201121144434-x2ulo2n" data-node-id="20201121144434-x2ulo2n" data-type="NodeHeading" data-subtype="h4" class="h4" parent-fold="1">
      <div>
0x00 服务端方法
</div>
    </div>
<div id="20201121144434-tqfcfol" data-node-id="20201121144434-tqfcfol" data-type="NodeCodeBlock" class="code-block" parent-fold="1">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">// apis/time.ts
export function currentTime() {
  return Date.now();
}

export function currentTime2(toLocaleString: boolean) {
  if (toLocaleString) {
    return new Date().toLocaleString();
  } else {
    return Date.now();
  }
}
</div>
      </div>
<div id="20201121144434-rkrn94r" data-node-id="20201121144434-rkrn94r" data-type="NodeParagraph" class="p" parent-fold="1">这里随便写了几个方法
</div>
<div id="20201121144434-5p37pxh" data-node-id="20201121144434-5p37pxh" data-type="NodeHeading" data-subtype="h4" class="h4" parent-fold="1">
      <div>
0x01 聚合
</div>
    </div>
<div id="20201121144434-v6a2q4u" data-node-id="20201121144434-v6a2q4u" data-type="NodeCodeBlock" class="code-block" parent-fold="1">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">// apis/index.ts
export * from "./time";
</div>
      </div>
<div id="20201121144434-grh37hy" data-node-id="20201121144434-grh37hy" data-type="NodeParagraph" class="p" parent-fold="1">约定俗称的用一个 
<span data-type="code">index.ts</span>
 文件将其他文件中的方法聚合起来。
</div>
<div id="20201121144434-f6awc68" data-node-id="20201121144434-f6awc68" data-type="NodeHeading" data-subtype="h4" class="h4" parent-fold="1">
      <div>
0x02 Remote Procedure Call !
</div>
    </div>
<div id="20201121144434-u2tnf4d" data-node-id="20201121144434-u2tnf4d" data-type="NodeParagraph" class="p" parent-fold="1">Remote Procedure Call 要说的高大上呢那也有很多可以做的细节，但我们追求简简单单。
</div>
<div id="20201121144434-llith0o" data-node-id="20201121144434-llith0o" data-type="NodeCodeBlock" class="code-block" parent-fold="1">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">// router/rpc.ts
import * as apis from "../apis";

export async function post(req: any, res: any) {
  const data = [] as any[];
  req.on("data", function (chunk) {
    data.push(chunk);
  });
  req.on("end", async () => {
    const { method, data: _data } = JSON.parse(data.join(""));
    const result = await apis[method](..._data);
    res.writeHead(200, {
      "Content-Type": "application/json"
    });
    res.end(JSON.stringify(result));
  });
}
</div>
      </div>
<div id="20201121144434-24hayq2" data-node-id="20201121144434-24hayq2" data-type="NodeParagraph" class="p" parent-fold="1">简单的远程调用只需要暴露一个接口让用户可以调用本机方法就行了
</div>
<div id="20201121144434-75b8h96" data-node-id="20201121144434-75b8h96" data-type="NodeHeading" data-subtype="h4" class="h4" parent-fold="1">
      <div>
0x03 TypeScript ! 🎉
</div>
    </div>
<div id="20201121144434-to5lrnx" data-node-id="20201121144434-to5lrnx" data-type="NodeCodeBlock" class="code-block" parent-fold="1">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">//  rpc.ts
/** ═════════🏳‍🌈 超轻量级的远程调用，完备的类型提示！ 🏳‍🌈═════════  */
import type * as apis from "./apis";
type apis = typeof apis;
type method = keyof apis;

/** Remote call ， 会就近的选择是远程调用还是使用本地函数 */
export function RC<K extends method>(
  method: K,
  data: Parameters<apis[K]>
): Promise<unPromise<ReturnType<apis[K]>>> {
  if (typeof window !== "undefined") {
    // 客户端运行
    return fetch("/rpc", {
      method: "POST",
      body: JSON.stringify({ method, data }),
      headers: {
        "content-type": "application/json"
      }
    }).then((r) => r.json());
  } else {
    // 服务端运行，使用 import 的原因是避免 apis 的代码被打包发送到客户端
    return import("./apis/index").then(async (r: any) => {
      return await r[method](...data);
    });
  }
}

/** 解开 promise 类型包装 */
declare type unPromise<T> = T extends Promise<infer R> ? R : T;

// 示例 1 直接使用 RC

RC("currentTime", []).then((r) => console.log("服务器当前时间", r));
RC("currentTime2", [true]).then((r) => console.log("服务器当前时间本地化", r));

/** 包装了一次的 RC 方便跳转到函数定义  */
export const API = new Proxy(
  {},
  {
    get(target, p: method) {
      return (...arg: any) => RC(p, arg);
    }
  }
) as apisPromiseify;

/** apis 中包含的方法可能不是返回 promise 的，但 RC 调用后的一定是返回 promsie */
type apisPromiseify = {
  readonly [K in keyof apis]: (
    ...arg: Parameters<apis[K]>
  ) => Promise<unPromise<ReturnType<apis[K]>>>;
};

// 示例 2 通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处

API.currentTime().then((r) => console.log("服务器当前时间", r));
API.currentTime2(true).then((r) => console.log("服务器当前时间本地化", r));

</div>
      </div>
<div id="20201121144434-xjmhrz7" data-node-id="20201121144434-xjmhrz7" data-type="NodeParagraph" class="p" parent-fold="1">上面就是一顿类型操作，打完收工。
</div>
<div id="20201121144434-bvogew0" data-node-id="20201121144434-bvogew0" data-type="NodeParagraph" class="p" parent-fold="1">接下来无论是在服务端还是客户端通过 RC 或 API 来调用方法获得的体验是一模一样的。
</div>
<div id="20201121144434-65amyu0" data-node-id="20201121144434-65amyu0" data-type="NodeParagraph" class="p" parent-fold="1">并且通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处。啥类型提示都有，接口文档也没有必要了。
</div>
<div id="20201121144434-m2hjyfb" data-node-id="20201121144434-m2hjyfb" data-type="NodeHeading" data-subtype="h4" class="h4" parent-fold="1">
      <div>
总结
</div>
    </div>
<div id="20201121144434-k066v3c" data-node-id="20201121144434-k066v3c" data-type="NodeParagraph" class="p" parent-fold="1">这个
<span data-type="s">项目</span>
 方法 的重点在于复用了服务端提供接口的类型，并且可以直接跳转过去。
</div>
<div id="20201121144434-crk7nwo" data-node-id="20201121144434-crk7nwo" data-type="NodeParagraph" class="p" parent-fold="1">追求简单的方法，完善类型体验。
</div>
<div id="20201121144434-xm6il3l" data-node-id="20201121144434-xm6il3l" data-type="NodeParagraph" class="p" parent-fold="1">我写出这个想法之后觉得我以前就是憨憨，自己写一个项目还维护一份接口文档 😀。
</div>
<div id="20210410111356-yn9t6h2" data-node-id="20210410111356-yn9t6h2" data-type="NodeThematicBreak" class="hr" parent-fold="1"><div></div></div>
<div id="20201121144434-mruhrq1" data-node-id="20201121144434-mruhrq1" data-type="NodeParagraph" class="p" parent-fold="1">现在 codesandbox 还不支持中文文件名，坑了我一把
</div>
<div id="20201121144434-jcq53xy" data-node-id="20201121144434-jcq53xy" data-type="NodeParagraph" class="p" parent-fold="1"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201109171018-un3fain-image.png"
        data-src="./../../../assets/20201109171018-un3fain-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201121144434-wjhqdxr" data-node-id="20201121144434-wjhqdxr" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
2020-11-13
</div>
    </div>
<div id="20201113135603-vp1h5po" data-node-id="20201113135603-vp1h5po" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
数组求和
</div>
    </div>
<div id="20201121144434-idlpfk1" data-node-id="20201121144434-idlpfk1" data-type="NodeCodeBlock" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">/** 数组求和 */
export function ArraySum<T>(arr: T[], f: (el: T) => number) {
  return arr.map(f).reduce((a, b) => a + b, 0);
}
</div>
      </div>
<div id="20201113135603-t17a0wt" data-node-id="20201113135603-t17a0wt" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
数组去重 ＆ 求和
</div>
    </div>
<div id="20201121144434-rrz8gbs" data-node-id="20201121144434-rrz8gbs" data-type="NodeCodeBlock" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">/** 数组去重
 * 1. 可以设置函数来决定什么样算重复
 * 2. 可以设置函数来决定遇到重复的结果该怎么合并
 */
export function Array去重<T>(
  arr: T[],
  /** 需要返回该对象的一个唯一标识（需要是原始值 用于和其他的进行比较） */ f: (el: T) => unknown = (el: T) => el,
  /** 用于决定和重复对象的合并方式，默认取后面的值，丢弃旧值 */ mergeF: (a: T, b: T) => T = (a, b) => b,
) {
  let result = [] as T[];
  let label = [] as unknown[];

  for (const el of arr) {
    const id = f(el);
    const i = label.findIndex((el) => el === id);
    if (i !== -1) {
      result[i] = mergeF(result[i], el);
    } else {
      label.push(id);
      result.push(el);
    }
  }

  return result;
}

</div>
      </div>
<div id="20201113135603-ohicvju" data-node-id="20201113135603-ohicvju" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
数组取随机 n 个元素
</div>
    </div>
<div id="20201121144434-ekt6aqd" data-node-id="20201121144434-ekt6aqd" data-type="NodeCodeBlock" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">/** 从数组中随机取 n 个元素 */
export function sampleSize<T>([...arr]: T[], n = 1) {
  let m = arr.length;
  while (m) {
    const i = Math.floor(Math.random() * m--);
    [arr[m], arr[i]] = [arr[i], arr[m]];
  }
  return arr.slice(0, n);
}
</div>
      </div>
<div id="20210410111356-x53fin8" data-node-id="20210410111356-x53fin8" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-lxzu4lp" data-node-id="20201121144434-lxzu4lp" data-type="NodeParagraph" class="p">今天（2020-11-17）发现 GitHub 的消息那里的分页也是存在问题的，就是在一开始如果有两页数据一直点已读然后点下一页发现是空的，再点上一页才能看见消息
</div>
<div id="20210410111356-yijmpun" data-node-id="20210410111356-yijmpun" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-vkdjwe2" data-node-id="20201121144434-vkdjwe2" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
使用编辑距离算法为自己的博客生成 404 页面的导流推荐
</div>
    </div>
<div id="20201121144434-khbbzq0" data-node-id="20201121144434-khbbzq0" data-type="NodeParagraph" class="p">例如本文正确地址  
<a href="https://shenzilong.cn/record/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/2020/11%E2%80%B8%E6%9C%88.html">https://shenzilong.cn/record/每日总结/2020/11 月.html</a>
  ，如果用户输入错了写成了  
<a href="https://shenzilong.cn/record/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93%E2%80%B82020/11%E6%9C%88.html">https://shenzilong.cn/record/每日总结 2020/11 月.html</a>
  （每日总结后面少了个 「/」）
</div>
<div id="20201121144434-ztts54n" data-node-id="20201121144434-ztts54n" data-type="NodeParagraph" class="p"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201117100730-7in4b2o-image.png"
        data-src="./../../../assets/20201117100730-7in4b2o-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201121144434-lkcozjb" data-node-id="20201121144434-lkcozjb" data-type="NodeParagraph" class="p">咱依旧能如图中这般推荐给用户他可能想要访问的地址 😀
</div>
<div id="20201121144434-xd27kjb" data-node-id="20201121144434-xd27kjb" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
编辑距离算法
</div>
    </div>
<div id="20201121144434-crj1v0i" data-node-id="20201121144434-crj1v0i" data-type="NodeCodeBlock" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          typescript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">/** 求两个数组的编辑距离 */
export function minDistance<T>(l1: T[], l2: T[], equal?: (i1: number, i2: number) => boolean): number {
  if (equal === undefined) {
    /** 比较对应位置的元素是否相等 */
    return minDistance(l1, l2, (i1, i2) => l1[i1] === l2[i2]);
  }
  const len1 = l1.length;
  const len2 = l2.length;

  let matrix = [] as any;

  for (let i = 0; i <= len1; i++) {
    // 构造二维数组
    matrix[i] = [];
    for (let j = 0; j <= len2; j++) {
      // 初始化
      if (i == 0) {
        matrix[i][j] = j;
      } else if (j == 0) {
        matrix[i][j] = i;
      } else {
        // 进行最小值分析
        let cost = 0;
        if (!equal(i - 1, j - 1)) {
          // 相同为0，不同置1
          cost = 1;
        }
        const temp = matrix[i - 1][j - 1] + cost;

        matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, temp);
      }
    }
  }
  return matrix[len1][len2]; //返回右下角的值
}

</div>
      </div>
<div id="20201121144434-kneqllv" data-node-id="20201121144434-kneqllv" data-type="NodeParagraph" class="p">作为调包侠的我只要知道 
<span data-type="code">minDistance</span>
 可以只传入两数组，他就返回一个数值表示这两数组之间的差异，数值越大差异越大就可以了
</div>
<div id="20201121144434-jkgc1v6" data-node-id="20201121144434-jkgc1v6" data-type="NodeParagraph" class="p">然后就是获取全站链接与用户输入地址一一比较返回差异最小的五个给用户查看
</div>
<div id="20210410111356-z0h2jox" data-node-id="20210410111356-z0h2jox" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201117144207-xqseawh" data-node-id="20201117144207-xqseawh" data-type="NodeHeading" data-subtype="h2" class="h2" bookmark="表情包">
      <div>
<span data-type="tag">图/表情包</span>
 鸽子漫步
</div>
    </div>
<div id="20201121144434-6ts0i0w" data-node-id="20201121144434-6ts0i0w" data-type="NodeParagraph" class="p"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201117144233-sle91fx-漫步鸽.gif"
        data-src="./../../../assets/20201117144233-sle91fx-漫步鸽.gif"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20210410111356-9fgxjap" data-node-id="20210410111356-9fgxjap" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-73nq0u1" data-node-id="20201121144434-73nq0u1" data-type="NodeParagraph" class="p">今天（2020/11/19）开始使用 go 写一个 
<a href="https://github.com/2234839/md2website">https://github.com/2234839/md2website</a>
 从 Markdown 生成静态站点的工具，现写现学竟也写出了一个简单的转换工具了。
</div>
<div id="20201121144434-ks6tuz7" data-node-id="20201121144434-ks6tuz7" data-type="NodeParagraph" class="p">目前的体验是感觉 ts 的那种类型设计才是最爽的，go 的类型系统还是没有那么舒服。
</div>
<div id="20210410111356-w475lvf" data-node-id="20210410111356-w475lvf" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121144434-7gezmed" data-node-id="20201121144434-7gezmed" data-type="NodeBlockquote" class="bq">
<div id="20201121144434-03759kw" data-node-id="20201121144434-03759kw" data-type="NodeParagraph" class="p">我们就当做无事发生过/
</div>
</div>
<div id="20201121144434-jsqv5nq" data-node-id="20201121144434-jsqv5nq" data-type="NodeParagraph" class="p">突然觉得这句话很带感
</div>
<div id="20210410111356-cixcfg2" data-node-id="20210410111356-cixcfg2" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121145148-ul83mdn" data-node-id="20201121145148-ul83mdn" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
<span data-type="tag">图/常规</span>
 中华人民共和国国旗
</div>
    </div>
<div id="20201121145549-tsrkvr8" data-node-id="20201121145549-tsrkvr8" data-type="NodeParagraph" class="p" bookmark="美图"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201121145933-o08j411-国旗.png"
        data-src="./../../../assets/20201121145933-o08j411-国旗.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20210410111356-91x6944" data-node-id="20210410111356-91x6944" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201121151501-h9rq4ka" data-node-id="20201121151501-h9rq4ka" data-type="NodeParagraph" class="p">思源嵌入块查询好玩呀 
<span data-type="code">{{SELECT * FROM blocks ORDER BY id desc LIMIT 20}} </span>
只需要这样就可以看到自己最近更新了哪些块（需要开启关闭程序时保持块 ID）
<span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201121151517-u2mnrct-image.png"
        data-src="./../../../assets/20201121151517-u2mnrct-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201121152343-8ncw7d9" data-node-id="20201121152343-8ncw7d9" data-type="NodeParagraph" class="p"><a href="https://ld246.com/article/1605943137935"><span data-type="tag">分享/链滴/块查询</span></a>
</div>
<div id="20210410111356-95du7pz" data-node-id="20210410111356-95du7pz" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201123155705-e3pqbzo" data-node-id="20201123155705-e3pqbzo" data-type="NodeParagraph" class="p"><span data-type="tag">vue/composition-api</span>
 获取当前实例的方法 ： 
<span data-type="code">getCurrentInstance()</span>
 尤其需要注意的是 
<span data-type="code">ctx.root !== this</span>
 我一开始错误的以为 ctx.root 就等于选项式风格中方法的 this 了，但实际上不是的 (我也不清楚我为什么会有这么奇怪的认为 🤣，仔细想想 
<span data-type="mark">root 怎么会是 当前实例呢？</span>
)
</div>
<div id="20201225090434-gnyv0j6" data-node-id="20201225090434-gnyv0j6" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201125113305-corv1aw" data-node-id="20201125113305-corv1aw" data-type="NodeParagraph" class="p">利用 vditor 渲染的效果很好 
<a href="https://2234839.github.io/md2website/Markdown%20使用指南/Markdown%20完整示例.html">Markdown 完整示例</a>
 再美化一下菜单页面 
<span data-type="block-ref"     data-subtype="s"     data-id="20201121142503-ivwtfzg">
          <a href="./../../../想法/项目/OceanPress.html#20201121142503-ivwtfzg">md2website</a>
  </span>
 就基本可用了 🎉
</div>
<div id="20210410111356-b9sf7wz" data-node-id="20210410111356-b9sf7wz" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201125145745-dyrg33g" data-node-id="20201125145745-dyrg33g" data-type="NodeBlockquote" class="bq">
<div id="20201125145747-zl3snso" data-node-id="20201125145747-zl3snso" data-type="NodeParagraph" class="p">（1）量入为出，适度消费
​
（2）避免盲从，理性消费
​
（3）保护环境，绿色消费
​
（4）勤俭节约，艰苦奋斗
</div>
</div>
<div id="20210410111356-h0kulfs" data-node-id="20210410111356-h0kulfs" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201225090831-y77a9d5" data-node-id="20201225090831-y77a9d5" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
<span data-type="tag">图/常规</span>
 唐僧五指山放悟空
</div>
    </div>
<div id="20201125151719-aa68cbq" data-node-id="20201125151719-aa68cbq" data-type="NodeParagraph" class="p" bookmark="美图"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201125151719-082ha07.hxd"
        data-src="./../../../assets/20201125151719-082ha07.hxd"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201125151721-qhgpl5n" data-node-id="20201125151721-qhgpl5n" data-type="NodeParagraph" class="p">这个封面还挺好看，
<a href="https://www.zhihu.com/question/431763472/answer/1592806293">来源-如何看待《中国化学》一论文通讯作者把自己 P 成女娲，作为期刊封面？ - Genebox 基因宝的回答 - 知乎</a>
</div>
<div id="20210410111356-63nx3a9" data-node-id="20210410111356-63nx3a9" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201126145719-p3i6thk" data-node-id="20201126145719-p3i6thk" data-type="NodeHeading" data-subtype="h2" class="h2">
      <div>
uniapp 体积优化秘技
</div>
    </div>
<div id="20201126161118-q0hzqmi" data-node-id="20201126161118-q0hzqmi" data-type="NodeParagraph" class="p"><a href="https://ask.dcloud.net.cn/article/38134"><span data-type="tag">分享/dcloud/uniapp 体积优化秘技</span></a>
</div>
<div id="20201126145734-dtvlebt" data-node-id="20201126145734-dtvlebt" data-type="NodeParagraph" class="p">这个方法很简单很有效，只有一句话「不要在 main.js 中加任何一行代码」
</div>
<div id="20201126145847-f5o1z8x" data-node-id="20201126145847-f5o1z8x" data-type="NodeParagraph" class="p">下面是我的一个示例
</div>
<div id="20201126145837-8bey6zs" data-node-id="20201126145837-8bey6zs" data-type="NodeParagraph" class="p"><span data-type="NodeImage" class="img" style="undefined"
      ><img
        src="./../../../assets/20201126145837-hh3xhlb-image.png"
        data-src="./../../../assets/20201126145837-hh3xhlb-image.png"
        title=""
        style="undefined"
      /><span class="protyle-action__title"></span></span
    >
</div>
<div id="20201126145839-j4vhrjr" data-node-id="20201126145839-j4vhrjr" data-type="NodeParagraph" class="p">之前这个 main.ts 中还有很多其他杂七杂八的东西，预览的时候体积是 2321KB。都没有办法预览
</div>
<div id="20201126145952-iyvbgmm" data-node-id="20201126145952-iyvbgmm" data-type="NodeParagraph" class="p">全部移动到其他地方之后体积降到了 2138KB 虽然还是没有办法预览但体积确实减小了。
</div>
<div id="20201126150042-0xoemwn" data-node-id="20201126150042-0xoemwn" data-type="NodeParagraph" class="p">编译之后的体积也会有大幅缩小。
</div>
<div id="20201126150053-wzzkmha" data-node-id="20201126150053-wzzkmha" data-type="NodeHeading" data-subtype="h3" class="h3">
      <div>
原理
</div>
    </div>
<div id="20201126150101-w2rsnnb" data-node-id="20201126150101-w2rsnnb" data-type="NodeParagraph" class="p">uni-app 会将 main.js 中的代码 copy 一份到所有的 生成后的 js 文件中，这是没有必要的，我们将这些代码移动到其他文件然后被打包到 vendor.js 就可以避免这个问题。
</div>
<div id="20201126150207-nbspn7y" data-node-id="20201126150207-nbspn7y" data-type="NodeParagraph" class="p">即便你 main.js 中之前只有 30 行其他代码，但使用这个方法之后也会得到可观的体积优化。
</div>
<div id="20201126150432-bx6pwnm" data-node-id="20201126150432-bx6pwnm" data-type="NodeParagraph" class="p">这个方法我在两个项目中使用到了，即使编译后体积也有 100KB 以上的优化，当然这个优化的大小取决于你 main.js 中的代码数。如果你的项目中 main.js 中有很多代码的话这个方法值得一试！
</div>
<div id="20210410111356-cr5rzoy" data-node-id="20210410111356-cr5rzoy" data-type="NodeThematicBreak" class="hr"><div></div></div>
<div id="20201127101034-hnj6v6w" data-node-id="20201127101034-hnj6v6w" data-type="NodeParagraph" class="p"><span data-type="tag">uniapp/坑</span>
 在代码中 
<span data-type="code">import(&quot;page.json&quot;)</span>
 是没有办法拿到内容的，
<a href="https://github.com/dcloudio/uni-app/issues/302">GitHub 相关吐槽</a>
 (这里面有一个解决方案) ，我在里面提了一个使用 webpack 的 loader 来获取的方案
</div>
<div id="20201127102055-x8lr93u" data-node-id="20201127102055-x8lr93u" data-type="NodeCodeBlock" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">
          javascript
          </span>
            <span class="fn__flex-1"></span>
            <span class="protyle-icon protyle-icon--only protyle-action__copy">
            <svg><use xlink:href="#iconCopy"></use></svg>
          </span>
        </div>
        <div class="hljs" spellcheck="false">import("!!raw-loader!../pages.json").then((r) => {
  console.log("[r]", r);
});
</div>
      </div>
<div id="20210410111356-0nmefcg" data-node-id="20210410111356-0nmefcg" data-type="NodeThematicBreak" class="hr"><div></div></div>


        </div>
        <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/appearance/icons/material/icon.js?2.10.5"></script>
        <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/build/export/protyle-method.js?2.10.5"></script>
        <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle/js/lute/lute.min.js?2.10.5"></script>
        <script>
          window.siyuan = {
            config: {
              appearance: {
                mode: 0,
                codeBlockThemeDark: "base16/dracula",
                codeBlockThemeLight: "github",
              },
              editor: {
                codeLineWrap: true,
                codeLigatures: false,
                plantUMLServePath: "https://www.plantuml.com/plantuml/svg/~1",
                codeSyntaxHighlightLineNum: true,
                katexMacros: JSON.stringify({}),
              },
            },
            languages: { copy: "复制" },
          };
          const previewElement = document.getElementById("preview");
          Protyle.highlightRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.mathRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle", false);
          Protyle.mermaidRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.flowchartRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.graphvizRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.chartRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.mindmapRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.abcRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          Protyle.htmlRender(previewElement);
          Protyle.plantumlRender(previewElement, "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@main/apps/frontend/public/notebook/stage/protyle");
          document.querySelectorAll(".protyle-action__copy").forEach((item) => {
            item.addEventListener("click", (event) => {
              navigator.clipboard.writeText(
                item.parentElement.nextElementSibling.textContent.trimEnd(),
              );
              event.preventDefault();
              event.stopPropagation();
            });
          });
        </script>
        <footer>
  <p style="text-align:center;margin:15px 0;">
    技术支持：
    <a target="_blank" href="https://github.com/2234839/oceanPress_js">OceanPress</a> |
    开发者：
    <a target="_blank" href="https://heartstack.space/user/%E5%AD%90%E8%99%9A/posts">崮生（子虚）</a>
  </p>
</footer>
      </body>
    </html>