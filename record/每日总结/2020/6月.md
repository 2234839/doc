# 6 月

- pubdate:2020-06-02 12:50:46
- tags:每日总结

---

## 2020-6-2

### VueX 与 ts 的结合**进阶**版

> 写出来这个功能之后，虽然回头看很简单。但我好像得到了某种升华，不仅仅是这段代码进阶了，我能感觉到我也进阶了

```typescript
import Vue from "vue";
import Vuex from "vuex";
import { API } from "@/services/mods";
import { debounce } from "@/util/util_fun";
import { config } from "@/config";
Vue.use(Vuex);
/** __开头的属性是不会保存到store 的 */
const _state = {
  user_info: {} as typeof API.报表开发移动端.postCustomerInfoValidateLogin.init["data"],
  wxUsers: {} as un_return_promise<typeof API.报表开发移动端.postCustomerInfoFindCustomerInfoList.request>["data"],
  /** 日报的缓存 */
  daily_cache: {},
  /** [这里进去的时候会查询这个缓存](src\pages\mine\view_subordinate_schedule\_view_subordinate_schedule_list.ts) */
  查看下级选人缓存: [] as string[],
  /** 当前选择的日程展示方式
   *
   * **副作用** 会设置tabBar index为1的按钮的text为当前值
   */
  scheduleType: "日程" as "日程" | "周程" | "月程",
  /** 当前选中的tab地址 */
  __tabPath: "",
  __1: "测试存储",
};

const cache_state = uni.getStorageSync("state");
Object.assign(_state, cache_state);
type mutations_key = keyof typeof mutations;

/**
 * **注意** 这里的 mutations 里面的函数入参和vuex的要求是颠倒的,
 * 原因是为了 commit.set_packet_token 这样的方法可以直接跳转过来，
 * 在store_options中我是包了一层函数将参数调转位置交给这里面的函数
 *
 * **最后一个 state 参数不应该传入**
 * */
const mutations = {
  set_user_info(user_info: typeof _state.user_info, state = _state) {
    state.user_info = user_info;
  },
  set_packet_token(packet_token: string, state = _state) {
    state.user_info.packet_token = packet_token;
  },
  set_wxUsersVoList(wxUsers: typeof _state.wxUsers, state = _state) {
    state.wxUsers = wxUsers;
  },
  set_daily_cache(daily_cache: typeof _state.daily_cache, state = _state) {
    state.daily_cache = daily_cache;
  },
  /** **jsdoc注释测试** */
  set_查看下级选人缓存(查看下级选人缓存: typeof _state.查看下级选人缓存, state = _state) {
    state.查看下级选人缓存 = 查看下级选人缓存;
  },
  set_tabPath(tabPath: typeof _state.__tabPath, state = _state) {
    state.__tabPath = tabPath;
  },

  set_scheduleType(scheduleType: typeof _state.scheduleType, state = _state) {
    state.scheduleType = scheduleType;
  },
};
const store_options = {
  state: {} as typeof _state,
  mutations: (() => {
    var obj = {} as any;
    for (const key in mutations) {
      const f = mutations[key as keyof typeof mutations];
      /** 倒置入参，使参数顺序实际为正常 */
      obj[key] = function (state: any, ...payload: any[]) {
        //@ts-ignore
        return f(...payload, state);
      };
    }
    return obj;
  })(),
};

export const store = new Vuex.Store(store_options);

store.watch(
  (state) => {
    return state.scheduleType;
  },
  (scheduleType) => {
    uni.setTabBarItem({
      index: 1,
      text: scheduleType,
    });
    $emit_event("日程切换", scheduleType);
  },
);
/** 在这里使用 replaceState 而非直接在 store_options 赋值的原因是为了store.watch第一次加载的时候也可以生效 */
store.replaceState(_state);
/** vuex 的commit */
export const commit = {} as typeof mutations;

for (const key in store_options.mutations) {
  commit[key as mutations_key] = (data: any) => {
    return store.commit(key, data);
  };
}

/** 存储 store */
store.subscribe(
  debounce((mutation: any, state: any) => {
    if (config.isDev) {
      console.log(state);
    }
    const data = JSON.parse(JSON.stringify(state));
    for (const key in data) {
      /** 剔除 __ 开头的属性，这种属性不用存储 */
      if (data.hasOwnProperty(key) && key.startsWith("__")) {
        delete data[key];
      }
    }
    uni.setStorage({ key: "state", data: data });
  }, 200),
);
```

## 2020-6-4

### [sapper-postcss-tailwind-rollup](https://github.com/langbamit/sapper-postcss-tailwind-rollup)

发现了这个结合了 tailwind 的 sapper 模板项目，并用它搭建了一个公司内的 ssr 服务

## 2020-6-5

### [node-tenpay](https://github.com/befinal/node-tenpay)

这是一个 node 的微信支付相关的库，用起来很不错，今天很简单的利用它搭建了一个支付的服务

核心代码如下，一开始我还只用了 api.unifiedOrder 返回的结果作为参数去调用微信的支付服务，结果不对。仔细看了下文档发现应当使用 api.getPayParamsByPrepay 来构造请求的参数

```javascript
let result_unifiedOrder = await api.unifiedOrder({
  out_trade_no: Date.now() + "",
  body: "测试统一下单",
  /** 订单金额(分) */
  total_fee: "1",
  openid: "or_wc5NwKRewBjZE9hRmYVj1aFto",
});
let result_PayParams = await api.getPayParamsByPrepay({
  prepay_id: result_unifiedOrder.prepay_id,
});
const result = { result_unifiedOrder, result_PayParams };
```

## 2020-6-6

### [ansi_up](https://www.npmjs.com/package/ansi_up)

这个库可以将 ansi 转为 html ，另外写了一个[小脚本](https://greasyfork.org/zh-CN/scripts/404778-ansi-to-html)，用于将 jenkins 中的输出利用这个库转为 html，看起来舒服多了

### parcel css in js

我在写油猴脚本时经常有加载 css 的需求，这时利用打包工具直接将 css 内联到 js 中就十分有用

但 parcel 对于这种情况目前 `import '***.css'` 是不会将 css 内联进去的，我从 https://github.com/parcel-bundler/parcel/issues/1370 找到了内联 css 的方法，虽然感觉并不优雅

```javascript
var css = fs.readFileSync("./ansi_to_html/ansi_to_html.css", "utf-8"); // <-- The css reader
var style = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode(css));
```