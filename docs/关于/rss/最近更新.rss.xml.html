<!DOCTYPE html>
<html lang="zh_CN" data-theme-mode="light" data-light-theme="daylight" data-dark-theme="midnight">
<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/>
<style>
  .header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
  }
  .home-button {
    text-decoration: none;
    color: #007bff;
    font-weight: bold;
    font-size: 16px;
  }
  .home-button:hover {
    text-decoration: underline;
  }
  #search {
    width: 300px;
  }
</style>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <link rel="stylesheet" type="text/css" id="baseStyle" href="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/stage/build/export/base.css?2.10.5"/>
  <script>
  function isNightTime() {
    const currentHour = new Date().getHours();
    return currentHour >= 18 || currentHour < 6;
  }
  document.write('<link rel="stylesheet" type="text/css" id="themeDefaultStyle" href="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/appearance/themes/'+(isNightTime()?'midnight':'daylight')+'/theme.css?2.10.5"/>');
  </script>
  <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/appearance/oceanpress.css"/>
  <title>最近更新.rss.xml</title>
</head>
<body>
  <div class="header-container">
  <a href="/" class="home-button">首页</a>
  <div id="search"></div>
</div>

  <div class="protyle-wysiwyg protyle-wysiwyg--attr" id="preview">
  <div style="min-height: 150px;" id="20210606154842-rgtj4rm" data-node-id="20210606154842-rgtj4rm" data-type="NodeDocument" updated="20240619103229" data-subtype="h1" class="h1" scroll="&#123;&quot;rootId&quot;:&quot;20210606154842-rgtj4rm&quot;,&quot;startId&quot;:&quot;20210606154842-jah9dt8&quot;,&quot;endId&quot;:&quot;20210606160324-57c0iql&quot;,&quot;scrollTop&quot;:0,&quot;focusId&quot;:&quot;20210606154842-jah9dt8&quot;,&quot;focusStart&quot;:0,&quot;focusEnd&quot;:0&#125;" type="doc"></div><h1 id="20210606154842-rgtj4rm" data-node-id="20210606154842-rgtj4rm" data-type="NodeDocument" updated="20240619103229" data-subtype="h1" class="h1" scroll="&#123;&quot;rootId&quot;:&quot;20210606154842-rgtj4rm&quot;,&quot;startId&quot;:&quot;20210606154842-jah9dt8&quot;,&quot;endId&quot;:&quot;20210606160324-57c0iql&quot;,&quot;scrollTop&quot;:0,&quot;focusId&quot;:&quot;20210606154842-jah9dt8&quot;,&quot;focusStart&quot;:0,&quot;focusEnd&quot;:0&#125;" type="doc" data-type="NodeHeading" class="h1">最近更新.rss.xml</h1><div id="20210606154842-jah9dt8" data-node-id="20210606154842-jah9dt8" data-type="NodeBlockQueryEmbed" updated="20240619103229" style="height: 9998px;" data-type="NodeBlockquote" class="bq"><div id="20250203112552-b92abi2" data-node-id="20250203112552-b92abi2" data-type="NodeParagraph" updated="20250203112819" class="p"><div spellcheck="false">In a previous article titled <span data-type="block-ref" data-subtype="d" data-id="20250120091259-h7hf587"><a href="./../../index/对于依赖注入的思考/Suddenly Realized Why Dependency Injection Is Necessary.html#20250120091259-h7hf587">Suddenly Realized Why Dependency Injection Is Necessary</a></span>, I received a lot of feedback that pointed out significant flaws in my understanding. After some more study, I realized that the issue I was trying to address is not so much about Dependency Injection itself, but is closer to a concept known as <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/">Algebraic Effects</a>. Both Dependency Injection and Algebraic Effects aim to solve engineering challenges in programming, such as replacing function implementations without modifying old code.</div></div><div id="20250203112552-tzhlbvp" data-node-id="20250203112552-tzhlbvp" data-type="NodeParagraph" updated="20250203112752" class="p"><div spellcheck="false">此文由 ai 翻译自中文版 <span data-type="block-ref" data-subtype="d" data-id="20250202145716-wvgw7m7"><a href="./../../index/对于依赖注入的思考-二.html#20250202145716-wvgw7m7">对于依赖注入的思考-二</a></span></div></div><div id="20250203112657-l8rbguf" data-node-id="20250203112657-l8rbguf" data-type="NodeParagraph" updated="20250203112708" class="p"><div spellcheck="false">english：<span data-type="block-ref" data-subtype="d" data-id="20250203112550-q97m2ib"><a href="./../../index/对于依赖注入的思考-二/Reflections on Dependency Injection.html#20250203112550-q97m2ib">Reflections on Dependency Injection</a></span></div></div><div id="20250203112649-xu7cmza" data-node-id="20250203112649-xu7cmza" data-type="NodeThematicBreak" updated="20250203112649" class="hr"><div></div></div><div id="20250203112552-ftvqi9c" data-node-id="20250203112552-ftvqi9c" data-type="NodeThematicBreak" updated="20250203112552" class="hr"><div></div></div><h4 id="20250203112552-b2inuaq" data-node-id="20250203112552-b2inuaq" data-type="NodeHeading" updated="20250203112552" data-subtype="h4" class="h4">Example of Dependency Injection:</h4>
<div id="20250203112552-w5dwvng" data-node-id="20250203112552-w5dwvng" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {}
function baseFn_B() {}
function higherFn_B() {
    baseFn_A(); // call baseFn_A in higherFn_B
}

function higherFn_C() {
    higherFn_B(); // call higherFn_B
}
</div>
      </div>
<div id="20250203112552-7riwvxc" data-node-id="20250203112552-7riwvxc" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">The idea is that if I want to create a new function <span data-type="code">higherFn_C2</span>​ that differs from <span data-type="code">higherFn_C</span>​ only in that it calls <span data-type="code">baseFn_B</span>​ instead of <span data-type="code">baseFn_A</span>​, Dependency Injection allows me to achieve this without changing much of the existing code.</div></div><div id="20250203112552-w5dwvng" data-node-id="20250203112552-w5dwvng" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {}
function baseFn_B() {}
function higherFn_B() {
    baseFn_A(); // call baseFn_A in higherFn_B
}

function higherFn_C() {
    higherFn_B(); // call higherFn_B
}
</div>
      </div><div id="20250203112552-7riwvxc" data-node-id="20250203112552-7riwvxc" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">The idea is that if I want to create a new function <span data-type="code">higherFn_C2</span>​ that differs from <span data-type="code">higherFn_C</span>​ only in that it calls <span data-type="code">baseFn_B</span>​ instead of <span data-type="code">baseFn_A</span>​, Dependency Injection allows me to achieve this without changing much of the existing code.</div></div><h4 id="20250203112552-k5f3g1o" data-node-id="20250203112552-k5f3g1o" data-type="NodeHeading" updated="20250203112552" data-subtype="h4" class="h4">A Key Insight on Context Propagation:</h4>
<div id="20250203112552-iqyzd2f" data-node-id="20250203112552-iqyzd2f" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">I recently came up with an idea where context is passed using a variable named <span data-type="code">ctx</span>​. It starts as a global <span data-type="code">ctx</span>​, and then branches into a tree for each module and function, where the context is derived from its parent. This is similar to implementing Algebraic Effects and Dependency Injection, as it allows for easy runtime replacement of context variables like replacing a closure in code.</div></div><div id="20250203112552-iqyzd2f" data-node-id="20250203112552-iqyzd2f" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">I recently came up with an idea where context is passed using a variable named <span data-type="code">ctx</span>​. It starts as a global <span data-type="code">ctx</span>​, and then branches into a tree for each module and function, where the context is derived from its parent. This is similar to implementing Algebraic Effects and Dependency Injection, as it allows for easy runtime replacement of context variables like replacing a closure in code.</div></div><h4 id="20250203112552-vvlvdvy" data-node-id="20250203112552-vvlvdvy" data-type="NodeHeading" updated="20250203112552" data-subtype="h4" class="h4">Problems to Solve:</h4>
<div id="20250203112552-k4o68ue" data-node-id="20250203112552-k4o68ue" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-6w2cfix" data-node-id="20250203112552-6w2cfix" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-abrhnj8" data-node-id="20250203112552-abrhnj8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Changing logic without modifying old code</span>: The challenge is to alter logic without impacting existing code.</div></div>
    </div></div><div id="20250203112552-k4o68ue" data-node-id="20250203112552-k4o68ue" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-6w2cfix" data-node-id="20250203112552-6w2cfix" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-abrhnj8" data-node-id="20250203112552-abrhnj8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Changing logic without modifying old code</span>: The challenge is to alter logic without impacting existing code.</div></div>
    </div></div><div id="20250203112552-6w2cfix" data-node-id="20250203112552-6w2cfix" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-abrhnj8" data-node-id="20250203112552-abrhnj8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Changing logic without modifying old code</span>: The challenge is to alter logic without impacting existing code.</div></div>
    </div><div id="20250203112552-abrhnj8" data-node-id="20250203112552-abrhnj8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Changing logic without modifying old code</span>: The challenge is to alter logic without impacting existing code.</div></div><h4 id="20250203112552-y9amyk5" data-node-id="20250203112552-y9amyk5" data-type="NodeHeading" updated="20250203112552" data-subtype="h4" class="h4">Solutions Explored:</h4>
<div id="20250203112552-407hw8s" data-node-id="20250203112552-407hw8s" data-type="NodeList" updated="20250203112552" data-subtype="o" class="list"><div id="20250203112552-h7v613i" data-node-id="20250203112552-h7v613i" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="1.">
      <div class="protyle-action">
        1.
      </div>
      <div id="20250203112552-daa2ozy" data-node-id="20250203112552-daa2ozy" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Passing Parameters</span>:</div></div><div id="20250203112552-v2gqzpl" data-node-id="20250203112552-v2gqzpl" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-wny39e6" data-node-id="20250203112552-wny39e6" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div>
    </div></div><div id="20250203112552-225axo5" data-node-id="20250203112552-225axo5" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op) {
    return op();
}

function higherFn_B(op) {
    baseFn_A(op);
}
</div>
      </div><div id="20250203112552-u29zzo8" data-node-id="20250203112552-u29zzo8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This is a straightforward approach to Dependency Injection but becomes cumbersome as the number of parameters increases.</div></div><div id="20250203112552-23wdoav" data-node-id="20250203112552-23wdoav" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op, op2, op3) {
    return [op(), op2(), op3()];
}

function higherFn_B(op, op2, op3) {
    baseFn_A(op, op2, op3);
}
</div>
      </div><div id="20250203112552-74rkn3n" data-node-id="20250203112552-74rkn3n" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">Ideally, you want a way to modify only specific parameters without affecting others.</div></div><div id="20250203112552-ivi4h5v" data-node-id="20250203112552-ivi4h5v" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {
    const { op, op2, op3 } = requireFn();
    return [op(), op2(), op3()];
}

function higherFn_B() {
    setRequireFn({ op: () => {} });
    baseFn_A();
}
</div>
      </div>
    </div><div id="20250203112552-op0or38" data-node-id="20250203112552-op0or38" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="2.">
      <div class="protyle-action">
        2.
      </div>
      <div id="20250203112552-3erf1pe" data-node-id="20250203112552-3erf1pe" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Continuation Local Storage (CLS)</span>:</div></div><div id="20250203112552-2hbutfk" data-node-id="20250203112552-2hbutfk" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-t227zwy" data-node-id="20250203112552-t227zwy" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div>
    </div></div><div id="20250203112552-2hwib5o" data-node-id="20250203112552-2hwib5o" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
    const store = asyncLocalStorage.getStore() || {};
    asyncLocalStorage.enterWith({...store, ...data});
}

function requireFn() {
    return asyncLocalStorage.getStore() || {};
}
</div>
      </div><div id="20250203112552-xiwel74" data-node-id="20250203112552-xiwel74" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">While this works in Node.js, it is not available in browsers as the <span data-type="code">async_hooks</span>​ module does not exist there.</div></div>
    </div><div id="20250203112552-ux4ibbq" data-node-id="20250203112552-ux4ibbq" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="3.">
      <div class="protyle-action">
        3.
      </div>
      <div id="20250203112552-srjpbgo" data-node-id="20250203112552-srjpbgo" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Compromise: Passing Context Variables</span>:</div></div><div id="20250203112552-fi3jc27" data-node-id="20250203112552-fi3jc27" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-gj5do8g" data-node-id="20250203112552-gj5do8g" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div>
    </div></div><div id="20250203112552-ppq5set" data-node-id="20250203112552-ppq5set" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
    return {
        op: () => 'default op logic',
        op2: () => 'default op2 logic',
        op3: () => 'default op3 logic',
        op4: () => 'default op4 logic',
    };
}

function baseFn_A(ctx) {
    const { op, op2, op3, op4 } = ctx;
    return [op(), op2(), op3(), op4()];
}

function higherFn_B(ctx) {
    const newCtx = { ...ctx, op: () => 'New Op logic' };
    return baseFn_A(newCtx);
}

function higherFn_C(ctx) {
    const newCtx = {
        ...ctx,
        op: () => 'op result',
        op2: () => 'op2 result',
        op3: () => 'op3 result',
        op4: () => 'op4 result',
    };
    return higherFn_B(newCtx);
}
</div>
      </div>
    </div></div><div id="20250203112552-407hw8s" data-node-id="20250203112552-407hw8s" data-type="NodeList" updated="20250203112552" data-subtype="o" class="list"><div id="20250203112552-h7v613i" data-node-id="20250203112552-h7v613i" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="1.">
      <div class="protyle-action">
        1.
      </div>
      <div id="20250203112552-daa2ozy" data-node-id="20250203112552-daa2ozy" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Passing Parameters</span>:</div></div><div id="20250203112552-v2gqzpl" data-node-id="20250203112552-v2gqzpl" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-wny39e6" data-node-id="20250203112552-wny39e6" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div>
    </div></div><div id="20250203112552-225axo5" data-node-id="20250203112552-225axo5" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op) {
    return op();
}

function higherFn_B(op) {
    baseFn_A(op);
}
</div>
      </div><div id="20250203112552-u29zzo8" data-node-id="20250203112552-u29zzo8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This is a straightforward approach to Dependency Injection but becomes cumbersome as the number of parameters increases.</div></div><div id="20250203112552-23wdoav" data-node-id="20250203112552-23wdoav" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op, op2, op3) {
    return [op(), op2(), op3()];
}

function higherFn_B(op, op2, op3) {
    baseFn_A(op, op2, op3);
}
</div>
      </div><div id="20250203112552-74rkn3n" data-node-id="20250203112552-74rkn3n" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">Ideally, you want a way to modify only specific parameters without affecting others.</div></div><div id="20250203112552-ivi4h5v" data-node-id="20250203112552-ivi4h5v" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {
    const { op, op2, op3 } = requireFn();
    return [op(), op2(), op3()];
}

function higherFn_B() {
    setRequireFn({ op: () => {} });
    baseFn_A();
}
</div>
      </div>
    </div><div id="20250203112552-op0or38" data-node-id="20250203112552-op0or38" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="2.">
      <div class="protyle-action">
        2.
      </div>
      <div id="20250203112552-3erf1pe" data-node-id="20250203112552-3erf1pe" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Continuation Local Storage (CLS)</span>:</div></div><div id="20250203112552-2hbutfk" data-node-id="20250203112552-2hbutfk" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-t227zwy" data-node-id="20250203112552-t227zwy" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div>
    </div></div><div id="20250203112552-2hwib5o" data-node-id="20250203112552-2hwib5o" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
    const store = asyncLocalStorage.getStore() || {};
    asyncLocalStorage.enterWith({...store, ...data});
}

function requireFn() {
    return asyncLocalStorage.getStore() || {};
}
</div>
      </div><div id="20250203112552-xiwel74" data-node-id="20250203112552-xiwel74" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">While this works in Node.js, it is not available in browsers as the <span data-type="code">async_hooks</span>​ module does not exist there.</div></div>
    </div><div id="20250203112552-ux4ibbq" data-node-id="20250203112552-ux4ibbq" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="3.">
      <div class="protyle-action">
        3.
      </div>
      <div id="20250203112552-srjpbgo" data-node-id="20250203112552-srjpbgo" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Compromise: Passing Context Variables</span>:</div></div><div id="20250203112552-fi3jc27" data-node-id="20250203112552-fi3jc27" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-gj5do8g" data-node-id="20250203112552-gj5do8g" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div>
    </div></div><div id="20250203112552-ppq5set" data-node-id="20250203112552-ppq5set" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
    return {
        op: () => 'default op logic',
        op2: () => 'default op2 logic',
        op3: () => 'default op3 logic',
        op4: () => 'default op4 logic',
    };
}

function baseFn_A(ctx) {
    const { op, op2, op3, op4 } = ctx;
    return [op(), op2(), op3(), op4()];
}

function higherFn_B(ctx) {
    const newCtx = { ...ctx, op: () => 'New Op logic' };
    return baseFn_A(newCtx);
}

function higherFn_C(ctx) {
    const newCtx = {
        ...ctx,
        op: () => 'op result',
        op2: () => 'op2 result',
        op3: () => 'op3 result',
        op4: () => 'op4 result',
    };
    return higherFn_B(newCtx);
}
</div>
      </div>
    </div></div><div id="20250203112552-h7v613i" data-node-id="20250203112552-h7v613i" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="1.">
      <div class="protyle-action">
        1.
      </div>
      <div id="20250203112552-daa2ozy" data-node-id="20250203112552-daa2ozy" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Passing Parameters</span>:</div></div><div id="20250203112552-v2gqzpl" data-node-id="20250203112552-v2gqzpl" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-wny39e6" data-node-id="20250203112552-wny39e6" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div>
    </div></div><div id="20250203112552-225axo5" data-node-id="20250203112552-225axo5" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op) {
    return op();
}

function higherFn_B(op) {
    baseFn_A(op);
}
</div>
      </div><div id="20250203112552-u29zzo8" data-node-id="20250203112552-u29zzo8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This is a straightforward approach to Dependency Injection but becomes cumbersome as the number of parameters increases.</div></div><div id="20250203112552-23wdoav" data-node-id="20250203112552-23wdoav" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op, op2, op3) {
    return [op(), op2(), op3()];
}

function higherFn_B(op, op2, op3) {
    baseFn_A(op, op2, op3);
}
</div>
      </div><div id="20250203112552-74rkn3n" data-node-id="20250203112552-74rkn3n" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">Ideally, you want a way to modify only specific parameters without affecting others.</div></div><div id="20250203112552-ivi4h5v" data-node-id="20250203112552-ivi4h5v" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {
    const { op, op2, op3 } = requireFn();
    return [op(), op2(), op3()];
}

function higherFn_B() {
    setRequireFn({ op: () => {} });
    baseFn_A();
}
</div>
      </div>
    </div><div id="20250203112552-daa2ozy" data-node-id="20250203112552-daa2ozy" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Passing Parameters</span>:</div></div><div id="20250203112552-v2gqzpl" data-node-id="20250203112552-v2gqzpl" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-wny39e6" data-node-id="20250203112552-wny39e6" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div>
    </div></div><div id="20250203112552-wny39e6" data-node-id="20250203112552-wny39e6" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div>
    </div><div id="20250203112552-cuqhuox" data-node-id="20250203112552-cuqhuox" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">A simple method is passing functions as parameters, enabling logic changes without altering existing functions.</div></div><div id="20250203112552-225axo5" data-node-id="20250203112552-225axo5" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op) {
    return op();
}

function higherFn_B(op) {
    baseFn_A(op);
}
</div>
      </div><div id="20250203112552-u29zzo8" data-node-id="20250203112552-u29zzo8" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This is a straightforward approach to Dependency Injection but becomes cumbersome as the number of parameters increases.</div></div><div id="20250203112552-23wdoav" data-node-id="20250203112552-23wdoav" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op, op2, op3) {
    return [op(), op2(), op3()];
}

function higherFn_B(op, op2, op3) {
    baseFn_A(op, op2, op3);
}
</div>
      </div><div id="20250203112552-74rkn3n" data-node-id="20250203112552-74rkn3n" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">Ideally, you want a way to modify only specific parameters without affecting others.</div></div><div id="20250203112552-ivi4h5v" data-node-id="20250203112552-ivi4h5v" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A() {
    const { op, op2, op3 } = requireFn();
    return [op(), op2(), op3()];
}

function higherFn_B() {
    setRequireFn({ op: () => {} });
    baseFn_A();
}
</div>
      </div><div id="20250203112552-op0or38" data-node-id="20250203112552-op0or38" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="2.">
      <div class="protyle-action">
        2.
      </div>
      <div id="20250203112552-3erf1pe" data-node-id="20250203112552-3erf1pe" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Continuation Local Storage (CLS)</span>:</div></div><div id="20250203112552-2hbutfk" data-node-id="20250203112552-2hbutfk" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-t227zwy" data-node-id="20250203112552-t227zwy" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div>
    </div></div><div id="20250203112552-2hwib5o" data-node-id="20250203112552-2hwib5o" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
    const store = asyncLocalStorage.getStore() || {};
    asyncLocalStorage.enterWith({...store, ...data});
}

function requireFn() {
    return asyncLocalStorage.getStore() || {};
}
</div>
      </div><div id="20250203112552-xiwel74" data-node-id="20250203112552-xiwel74" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">While this works in Node.js, it is not available in browsers as the <span data-type="code">async_hooks</span>​ module does not exist there.</div></div>
    </div><div id="20250203112552-3erf1pe" data-node-id="20250203112552-3erf1pe" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Continuation Local Storage (CLS)</span>:</div></div><div id="20250203112552-2hbutfk" data-node-id="20250203112552-2hbutfk" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-t227zwy" data-node-id="20250203112552-t227zwy" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div>
    </div></div><div id="20250203112552-t227zwy" data-node-id="20250203112552-t227zwy" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div>
    </div><div id="20250203112552-6jqfla2" data-node-id="20250203112552-6jqfla2" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">CLS is useful for handling context in asynchronous environments like Node.js, where data needs to persist across asynchronous calls without explicitly passing it through each function.</div></div><div id="20250203112552-2hwib5o" data-node-id="20250203112552-2hwib5o" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
    const store = asyncLocalStorage.getStore() || {};
    asyncLocalStorage.enterWith({...store, ...data});
}

function requireFn() {
    return asyncLocalStorage.getStore() || {};
}
</div>
      </div><div id="20250203112552-xiwel74" data-node-id="20250203112552-xiwel74" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">While this works in Node.js, it is not available in browsers as the <span data-type="code">async_hooks</span>​ module does not exist there.</div></div><div id="20250203112552-ux4ibbq" data-node-id="20250203112552-ux4ibbq" data-type="NodeListItem" updated="20250203112552" data-subtype="o" class="li" data-marker="3.">
      <div class="protyle-action">
        3.
      </div>
      <div id="20250203112552-srjpbgo" data-node-id="20250203112552-srjpbgo" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Compromise: Passing Context Variables</span>:</div></div><div id="20250203112552-fi3jc27" data-node-id="20250203112552-fi3jc27" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-gj5do8g" data-node-id="20250203112552-gj5do8g" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div>
    </div></div><div id="20250203112552-ppq5set" data-node-id="20250203112552-ppq5set" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
    return {
        op: () => 'default op logic',
        op2: () => 'default op2 logic',
        op3: () => 'default op3 logic',
        op4: () => 'default op4 logic',
    };
}

function baseFn_A(ctx) {
    const { op, op2, op3, op4 } = ctx;
    return [op(), op2(), op3(), op4()];
}

function higherFn_B(ctx) {
    const newCtx = { ...ctx, op: () => 'New Op logic' };
    return baseFn_A(newCtx);
}

function higherFn_C(ctx) {
    const newCtx = {
        ...ctx,
        op: () => 'op result',
        op2: () => 'op2 result',
        op3: () => 'op3 result',
        op4: () => 'op4 result',
    };
    return higherFn_B(newCtx);
}
</div>
      </div>
    </div><div id="20250203112552-srjpbgo" data-node-id="20250203112552-srjpbgo" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false"><span data-type="strong">Compromise: Passing Context Variables</span>:</div></div><div id="20250203112552-fi3jc27" data-node-id="20250203112552-fi3jc27" data-type="NodeList" updated="20250203112552" data-subtype="u" class="list"><div id="20250203112552-gj5do8g" data-node-id="20250203112552-gj5do8g" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div>
    </div></div><div id="20250203112552-gj5do8g" data-node-id="20250203112552-gj5do8g" data-type="NodeListItem" updated="20250203112552" data-subtype="u" class="li" data-marker="*">
      <div class="protyle-action">
        <svg><use xlink:href="#iconDot"></use></svg>
      </div>
      <div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div>
    </div><div id="20250203112552-602koc6" data-node-id="20250203112552-602koc6" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">As a workaround, you can pass a <span data-type="code">ctx</span>​ object explicitly and modify it as needed.</div></div><div id="20250203112552-ppq5set" data-node-id="20250203112552-ppq5set" data-type="NodeCodeBlock" updated="20250203112552" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">javascript</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
    return {
        op: () => 'default op logic',
        op2: () => 'default op2 logic',
        op3: () => 'default op3 logic',
        op4: () => 'default op4 logic',
    };
}

function baseFn_A(ctx) {
    const { op, op2, op3, op4 } = ctx;
    return [op(), op2(), op3(), op4()];
}

function higherFn_B(ctx) {
    const newCtx = { ...ctx, op: () => 'New Op logic' };
    return baseFn_A(newCtx);
}

function higherFn_C(ctx) {
    const newCtx = {
        ...ctx,
        op: () => 'op result',
        op2: () => 'op2 result',
        op3: () => 'op3 result',
        op4: () => 'op4 result',
    };
    return higherFn_B(newCtx);
}
</div>
      </div><h4 id="20250203112552-xj9wlxl" data-node-id="20250203112552-xj9wlxl" data-type="NodeHeading" updated="20250203112552" data-subtype="h4" class="h4">Conclusion:</h4>
<div id="20250203112552-i43qgtn" data-node-id="20250203112552-i43qgtn" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This approach allows context to be modified dynamically, offering a cleaner way to achieve Dependency Injection or similar effects in JavaScript. For now, however, there are still limitations in certain environments (like browsers), and more work is needed to generalize these techniques.</div></div><div id="20250203112552-i43qgtn" data-node-id="20250203112552-i43qgtn" data-type="NodeParagraph" updated="20250203112552" class="p"><div spellcheck="false">This approach allows context to be modified dynamically, offering a cleaner way to achieve Dependency Injection or similar effects in JavaScript. For now, however, there are still limitations in certain environments (like browsers), and more work is needed to generalize these techniques.</div></div><h2 id="20250202171635-m6i49zy" data-node-id="20250202171635-m6i49zy" data-type="NodeHeading" updated="20250202174417" data-subtype="h2" class="h2">妥协的办法，传递上下文变量</h2>
<div id="20250202171725-her8ng9" data-node-id="20250202171725-her8ng9" data-type="NodeParagraph" updated="20250202172600" class="p"><div spellcheck="false">这个算是 <span data-type="block-ref" data-subtype="d" data-id="20250202164415-768ypor"><a href="./../../index/对于依赖注入的思考-二.html#20250202164415-768ypor">最显而易见的：参数传递</a></span> 办法的一种变种。</div></div>
<div id="20250202172830-12641m7" data-node-id="20250202172830-12641m7" data-type="NodeParagraph" updated="20250202172935" class="p"><div spellcheck="false">这里理论上还可以通过利用 react 所实现的代数效应来实现不传递 ctx 参数（在vue中就是利用 inject ）</div></div>
<div id="20250202172426-4s1qp1f" data-node-id="20250202172426-4s1qp1f" data-type="NodeCodeBlock" updated="20250202174417" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
  return {
    op: () => 'default op logic',
    op2: () => 'default op2 logic',
    op3: () => 'default op3 logic',
    op4: () => 'default op4 logic',
  };
}

function baseFn_A(ctx) {
  const { op, op2, op3, op4 } = ctx;  // 从传入的上下文中获取操作
  return [op(), op2(), op3(), op4()];
}

// 高阶函数 B，修改上下文并传递给 baseFn_A
function higherFn_B(ctx) {
  const newCtx = { ...ctx, op: () => 'New Op logic' };  // 创建新上下文
  return baseFn_A(newCtx);  // 将新的上下文传递给 baseFn_A
}
// 高阶函数 C，设置完整的上下文数据并传递给 higherFn_B
function higherFn_C(ctx) {
  const newCtx = {
    ...ctx,
    op: () => 'op result',
    op2: () => 'op2 result',
    op3: () => 'op3 result',
    op4: () => 'op4 result'
  };
  return higherFn_B(newCtx);  // 将新的上下文传递给 higherFn_B
}
const initialCtx = createContext();  // 创建初始上下文
console.log(higherFn_C(initialCtx));  // 输出：[ 'New Op logic', 'op2 result', 'op3 result', 'op4 result' ]
</div>
      </div><div id="20250202172426-4s1qp1f" data-node-id="20250202172426-4s1qp1f" data-type="NodeCodeBlock" updated="20250202174417" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function createContext() {
  return {
    op: () => 'default op logic',
    op2: () => 'default op2 logic',
    op3: () => 'default op3 logic',
    op4: () => 'default op4 logic',
  };
}

function baseFn_A(ctx) {
  const { op, op2, op3, op4 } = ctx;  // 从传入的上下文中获取操作
  return [op(), op2(), op3(), op4()];
}

// 高阶函数 B，修改上下文并传递给 baseFn_A
function higherFn_B(ctx) {
  const newCtx = { ...ctx, op: () => 'New Op logic' };  // 创建新上下文
  return baseFn_A(newCtx);  // 将新的上下文传递给 baseFn_A
}
// 高阶函数 C，设置完整的上下文数据并传递给 higherFn_B
function higherFn_C(ctx) {
  const newCtx = {
    ...ctx,
    op: () => 'op result',
    op2: () => 'op2 result',
    op3: () => 'op3 result',
    op4: () => 'op4 result'
  };
  return higherFn_B(newCtx);  // 将新的上下文传递给 higherFn_B
}
const initialCtx = createContext();  // 创建初始上下文
console.log(higherFn_C(initialCtx));  // 输出：[ 'New Op logic', 'op2 result', 'op3 result', 'op4 result' ]
</div>
      </div><div id="20250202153116-gj3p8rj" data-node-id="20250202153116-gj3p8rj" data-type="NodeBlockquote" updated="20250202173537" class="bq"><div id="20250202153117-owh3ap6" data-node-id="20250202153117-owh3ap6" data-type="NodeParagraph" updated="20250202153129" class="p"><div spellcheck="false">上下文传递方法使用一个同名变量ctx，起始于一个全局变量ctx然后从这个全局变量派生出来一棵树，每个模块乃至于函数都会有自己的ctx（从上级ctx 派生），许多需要的方法都是要从这个上下文中来获取</div></div><div id="20250202153129-5u8acis" data-node-id="20250202153129-5u8acis" data-type="NodeParagraph" updated="20250202173537" class="p"><div spellcheck="false">这个是实现一个类似代数效应以及依赖注入的方法<br>也等价于实现了一个可以操作的闭包环境，可以像在编码时替换一个闭包变量的实际指向一样容易的在运行时替换<br>最终就是为了部分的解决表达式问题 https://en.m.wikipedia.org/wiki/Expression_problem  </div></div></div><div id="20250202153129-5u8acis" data-node-id="20250202153129-5u8acis" data-type="NodeParagraph" updated="20250202173537" class="p"><div spellcheck="false">这个是实现一个类似代数效应以及依赖注入的方法<br>也等价于实现了一个可以操作的闭包环境，可以像在编码时替换一个闭包变量的实际指向一样容易的在运行时替换<br>最终就是为了部分的解决表达式问题 https://en.m.wikipedia.org/wiki/Expression_problem  </div></div><div id="20250202172830-12641m7" data-node-id="20250202172830-12641m7" data-type="NodeParagraph" updated="20250202172935" class="p"><div spellcheck="false">这里理论上还可以通过利用 react 所实现的代数效应来实现不传递 ctx 参数（在vue中就是利用 inject ）</div></div><div id="20250202171725-her8ng9" data-node-id="20250202171725-her8ng9" data-type="NodeParagraph" updated="20250202172600" class="p"><div spellcheck="false">这个算是 <span data-type="block-ref" data-subtype="d" data-id="20250202164415-768ypor"><a href="./../../index/对于依赖注入的思考-二.html#20250202164415-768ypor">最显而易见的：参数传递</a></span> 办法的一种变种。</div></div><h2 id="20250202164652-io9ywdn" data-node-id="20250202164652-io9ywdn" data-type="NodeHeading" updated="20250202171635" data-subtype="h2" class="h2">CLS来帮忙</h2>
<div id="20250202170436-xsqbs5h" data-node-id="20250202170436-xsqbs5h" data-type="NodeBlockquote" updated="20250202170530" class="bq"><div id="20250202170431-2iz1mut" data-node-id="20250202170431-2iz1mut" data-type="NodeParagraph" updated="20250202170431" class="p"><div spellcheck="false"><span data-type="strong">CLS（Continuation Local Storage）</span> 是一种在程序执行过程中，用于存储和传递跨异步操作的上下文数据的机制。在异步编程中，尤其是在像 Node.js 这样的环境中，跨越多个异步操作传递数据变得尤为复杂。CLS 允许你在不同的函数和异步任务中共享一些全局的上下文信息，而无需显式地将它们作为参数传递。CLS 的核心思想是：通过将数据与当前的执行上下文关联，确保在程序的控制流跨越异步边界时，这些数据能够随着控制流一起“传递”，而不需要通过显式的函数调用来传递。</div></div><div id="20250202170502-waoqyvu" data-node-id="20250202170502-waoqyvu" data-type="NodeParagraph" updated="20250202170530" class="p"><div spellcheck="false">在 Node.js 中，<span data-type="code">AsyncLocalStorage</span>​ 提供了一个实现 CLS 的工具，允许在异步操作的生命周期内存储和访问上下文数据。</div></div></div>
<div id="20250202170436-mhsz4c3" data-node-id="20250202170436-mhsz4c3" data-type="NodeParagraph" updated="20250202170436" class="p"><div spellcheck="false">在 Node.js 中，<span data-type="code">AsyncLocalStorage</span>​ 提供了一个实现 CLS 的工具，它允许你在异步操作的生命周期内存储和访问上下文数据。<span data-type="code">AsyncLocalStorage</span>​ 是基于 <span data-type="code">async_hooks</span>​ 模块构建的，专门设计用于在异步操作之间共享数据。</div></div>
<div id="20250202170218-8jobxzr" data-node-id="20250202170218-8jobxzr" data-type="NodeParagraph" updated="20250202170240" class="p"><div spellcheck="false">安装了 node 的可以尝试运行以下代码</div></div>
<div id="20250202165705-nw24iyq" data-node-id="20250202165705-nw24iyq" data-type="NodeCodeBlock" updated="20250202171356" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
  const store = asyncLocalStorage.getStore() || {};
  asyncLocalStorage.enterWith({...store,...data});
}

function requireFn() {
  return asyncLocalStorage.getStore() || {};
}

// -----------------------
function baseFn_A() {
  const { op, op2, op3, op4 } = requireFn();
  return [op(), op2(), op3(), op4()];
}
function higherFn_B() {
  setRequireFn({ op: () => 'New Op logic' });
  return baseFn_A();
}
function higherFn_C() {
  setRequireFn({
    op: () => 'op result',
    op2: () => 'op2 result',
    op3: () => 'op3 result',
    op4: () => 'op4 result'
  });
  return higherFn_B();
}
console.log(higherFn_C());  // 输出：['op result', 'op2 result', 'op3 result', 'op4 result']
</div>
      </div>
<div id="20250202170209-e8t0kv1" data-node-id="20250202170209-e8t0kv1" data-type="NodeParagraph" updated="20250202171634" class="p"><div spellcheck="false">看上去十分的美好了，但是...我之所以喜欢js就是因为代码可以运行在浏览器和node.js ，上面的代码只能支持node.js 但浏览器中是没有 async_hooks 模块的，<a href="https://github.com/orgs/JSCIG/discussions/9">【提案讨论】JavaScript 异步上下文 · JSCIG · Discussion #9 · GitHub</a> 这个提案似乎还遥遥无期。</div></div><div id="20250202170209-e8t0kv1" data-node-id="20250202170209-e8t0kv1" data-type="NodeParagraph" updated="20250202171634" class="p"><div spellcheck="false">看上去十分的美好了，但是...我之所以喜欢js就是因为代码可以运行在浏览器和node.js ，上面的代码只能支持node.js 但浏览器中是没有 async_hooks 模块的，<a href="https://github.com/orgs/JSCIG/discussions/9">【提案讨论】JavaScript 异步上下文 · JSCIG · Discussion #9 · GitHub</a> 这个提案似乎还遥遥无期。</div></div><div id="20250202165705-nw24iyq" data-node-id="20250202165705-nw24iyq" data-type="NodeCodeBlock" updated="20250202171356" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

function setRequireFn(data) {
  const store = asyncLocalStorage.getStore() || {};
  asyncLocalStorage.enterWith({...store,...data});
}

function requireFn() {
  return asyncLocalStorage.getStore() || {};
}

// -----------------------
function baseFn_A() {
  const { op, op2, op3, op4 } = requireFn();
  return [op(), op2(), op3(), op4()];
}
function higherFn_B() {
  setRequireFn({ op: () => 'New Op logic' });
  return baseFn_A();
}
function higherFn_C() {
  setRequireFn({
    op: () => 'op result',
    op2: () => 'op2 result',
    op3: () => 'op3 result',
    op4: () => 'op4 result'
  });
  return higherFn_B();
}
console.log(higherFn_C());  // 输出：['op result', 'op2 result', 'op3 result', 'op4 result']
</div>
      </div><div id="20250202170436-xsqbs5h" data-node-id="20250202170436-xsqbs5h" data-type="NodeBlockquote" updated="20250202170530" class="bq"><div id="20250202170431-2iz1mut" data-node-id="20250202170431-2iz1mut" data-type="NodeParagraph" updated="20250202170431" class="p"><div spellcheck="false"><span data-type="strong">CLS（Continuation Local Storage）</span> 是一种在程序执行过程中，用于存储和传递跨异步操作的上下文数据的机制。在异步编程中，尤其是在像 Node.js 这样的环境中，跨越多个异步操作传递数据变得尤为复杂。CLS 允许你在不同的函数和异步任务中共享一些全局的上下文信息，而无需显式地将它们作为参数传递。CLS 的核心思想是：通过将数据与当前的执行上下文关联，确保在程序的控制流跨越异步边界时，这些数据能够随着控制流一起“传递”，而不需要通过显式的函数调用来传递。</div></div><div id="20250202170502-waoqyvu" data-node-id="20250202170502-waoqyvu" data-type="NodeParagraph" updated="20250202170530" class="p"><div spellcheck="false">在 Node.js 中，<span data-type="code">AsyncLocalStorage</span>​ 提供了一个实现 CLS 的工具，允许在异步操作的生命周期内存储和访问上下文数据。</div></div></div><div id="20250202170502-waoqyvu" data-node-id="20250202170502-waoqyvu" data-type="NodeParagraph" updated="20250202170530" class="p"><div spellcheck="false">在 Node.js 中，<span data-type="code">AsyncLocalStorage</span>​ 提供了一个实现 CLS 的工具，允许在异步操作的生命周期内存储和访问上下文数据。</div></div><div id="20250202170436-mhsz4c3" data-node-id="20250202170436-mhsz4c3" data-type="NodeParagraph" updated="20250202170436" class="p"><div spellcheck="false">在 Node.js 中，<span data-type="code">AsyncLocalStorage</span>​ 提供了一个实现 CLS 的工具，它允许你在异步操作的生命周期内存储和访问上下文数据。<span data-type="code">AsyncLocalStorage</span>​ 是基于 <span data-type="code">async_hooks</span>​ 模块构建的，专门设计用于在异步操作之间共享数据。</div></div><div id="20250202170431-2iz1mut" data-node-id="20250202170431-2iz1mut" data-type="NodeParagraph" updated="20250202170431" class="p"><div spellcheck="false"><span data-type="strong">CLS（Continuation Local Storage）</span> 是一种在程序执行过程中，用于存储和传递跨异步操作的上下文数据的机制。在异步编程中，尤其是在像 Node.js 这样的环境中，跨越多个异步操作传递数据变得尤为复杂。CLS 允许你在不同的函数和异步任务中共享一些全局的上下文信息，而无需显式地将它们作为参数传递。CLS 的核心思想是：通过将数据与当前的执行上下文关联，确保在程序的控制流跨越异步边界时，这些数据能够随着控制流一起“传递”，而不需要通过显式的函数调用来传递。</div></div><div id="20250202170218-8jobxzr" data-node-id="20250202170218-8jobxzr" data-type="NodeParagraph" updated="20250202170240" class="p"><div spellcheck="false">安装了 node 的可以尝试运行以下代码</div></div><h2 id="20250202164415-yym259o" data-node-id="20250202164415-yym259o" data-type="NodeHeading" updated="20250202165632" data-subtype="h2" class="h2">寻找解决方案</h2><h3 id="20250202164415-768ypor" data-node-id="20250202164415-768ypor" data-type="NodeHeading" updated="20250202165632" data-subtype="h3" class="h3">最显而易见的：参数传递</h3>
<div id="20250202164415-wgx74r8" data-node-id="20250202164415-wgx74r8" data-type="NodeParagraph" updated="20250202164415" class="p"><div spellcheck="false">只要在编写旧代码的时候将需要被替换的函数作为参数就行了</div></div>
<div id="20250202164415-olbr8if" data-node-id="20250202164415-olbr8if" data-type="NodeCodeBlock" updated="20250202164417" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op){
	return op()，
}
function higherFn_B(op){
	baseFn_A(op)
}
</div>
      </div>
<div id="20250202164415-5rw3h5c" data-node-id="20250202164415-5rw3h5c" data-type="NodeParagraph" updated="20250202164415" class="p"><div spellcheck="false">通过传递一个函数，就可以在不修改 higherFn_B 函数代码的前提下（不修改旧代码）来改变旧代码的逻辑了</div></div>
<div id="20250202164415-nfgrhsj" data-node-id="20250202164415-nfgrhsj" data-type="NodeParagraph" updated="20250202165104" class="p"><div spellcheck="false">这也是最简单的依赖倒置的实践</div></div>
<div id="20250202164539-fe91mdu" data-node-id="20250202164539-fe91mdu" data-type="NodeParagraph" updated="20250202164746" class="p"><div spellcheck="false">上面这个实现是可行的，但在实际使用中会遇到下面这样的情况，很多层嵌套，很多的参数需要传递</div></div>
<div id="20250202164316-kbf7lkh" data-node-id="20250202164316-kbf7lkh" data-type="NodeCodeBlock" updated="20250202165223" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op,op2,op3,op4....){
	return [op()，op2(),op3(),op4()....()]
}
function higherFn_B(op,op2,op3,op4....){
	baseFn_A(op,op2,op3,op4....)
}
</div>
      </div>
<div id="20250202164532-gn2cyys" data-node-id="20250202164532-gn2cyys" data-type="NodeParagraph" updated="20250202165100" class="p"><div spellcheck="false">如果可以做到 baseFn_A 声明需要哪些参数，但中间的传递层可以选择覆盖其中的一些配置，也可以选择不用传递的话就好了，伪代码如下</div></div>
<div id="20250202164955-54a3g94" data-node-id="20250202164955-54a3g94" data-type="NodeCodeBlock" updated="20250202165608" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(){
	const {op,op2,op3,op4....} = requireFn()
	return [op()，op2(),op3(),op4()....()]
}
function higherFn_B(){
	// 覆盖 higherFn_C 传递的 op，但不影响op2,op3,op4....
    setRequireFn({op:()=>{}})
	baseFn_A()
}
function higherFn_C(){
    setRequireFn({op,op2,op3,op4....})
	higherFn_B()
}
</div>
      </div><div id="20250202164955-54a3g94" data-node-id="20250202164955-54a3g94" data-type="NodeCodeBlock" updated="20250202165608" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(){
	const {op,op2,op3,op4....} = requireFn()
	return [op()，op2(),op3(),op4()....()]
}
function higherFn_B(){
	// 覆盖 higherFn_C 传递的 op，但不影响op2,op3,op4....
    setRequireFn({op:()=>{}})
	baseFn_A()
}
function higherFn_C(){
    setRequireFn({op,op2,op3,op4....})
	higherFn_B()
}
</div>
      </div><div id="20250202164316-kbf7lkh" data-node-id="20250202164316-kbf7lkh" data-type="NodeCodeBlock" updated="20250202165223" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op,op2,op3,op4....){
	return [op()，op2(),op3(),op4()....()]
}
function higherFn_B(op,op2,op3,op4....){
	baseFn_A(op,op2,op3,op4....)
}
</div>
      </div><div id="20250202164415-nfgrhsj" data-node-id="20250202164415-nfgrhsj" data-type="NodeParagraph" updated="20250202165104" class="p"><div spellcheck="false">这也是最简单的依赖倒置的实践</div></div><div id="20250202164532-gn2cyys" data-node-id="20250202164532-gn2cyys" data-type="NodeParagraph" updated="20250202165100" class="p"><div spellcheck="false">如果可以做到 baseFn_A 声明需要哪些参数，但中间的传递层可以选择覆盖其中的一些配置，也可以选择不用传递的话就好了，伪代码如下</div></div><div id="20250202164539-fe91mdu" data-node-id="20250202164539-fe91mdu" data-type="NodeParagraph" updated="20250202164746" class="p"><div spellcheck="false">上面这个实现是可行的，但在实际使用中会遇到下面这样的情况，很多层嵌套，很多的参数需要传递</div></div><div id="20250202164415-olbr8if" data-node-id="20250202164415-olbr8if" data-type="NodeCodeBlock" updated="20250202164417" class="code-block">
        <div class="protyle-action">
          <span class="protyle-action--first protyle-action__language">js</span>
          <span class="fn__flex-1"></span><span class="protyle-icon protyle-icon--only protyle-action__copy"><svg><use xlink:href="#iconCopy"></use></svg></span>
        </div>
        <div class="hljs" spellcheck="false">function baseFn_A(op){
	return op()，
}
function higherFn_B(op){
	baseFn_A(op)
}
</div>
      </div><h2 id="20250202164415-s8dz9ex" data-node-id="20250202164415-s8dz9ex" data-type="NodeHeading" updated="20250202164415" data-subtype="h2" class="h2">需要解决的问题</h2>
<div id="20250202164415-rhugj6k" data-node-id="20250202164415-rhugj6k" data-type="NodeParagraph" updated="20250202164415" class="p"><div spellcheck="false"><span data-type="strong">在不修改旧代码的情况下修改他的逻辑</span></div></div></div><div id="20210606160324-57c0iql" data-node-id="20210606160324-57c0iql" data-type="NodeParagraph" updated="20230924170522" class="p"><div spellcheck="false"></div></div>
  </div>
  <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/appearance/icons/material/icon.js?2.10.5"></script>
  <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/stage/build/export/protyle-method.js?2.10.5"></script>
  <script src="https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/stage/protyle/js/lute/lute.min.js?2.10.5"></script>
  <script>
    window.siyuan = {
      config: {
        appearance: {
          mode: isNightTime()?1:0,//主题 明亮=0 暗黑=1
          codeBlockThemeDark: "base16/dracula",
          codeBlockThemeLight: "github",
        },
        editor: {
          codeLineWrap: true,
          codeLigatures: false,
          plantUMLServePath: "https://www.plantuml.com/plantuml/svg/~1",
          codeSyntaxHighlightLineNum: true,
          katexMacros: JSON.stringify({}),
        },
      },
      languages: { copy: "复制" },
    };
    const cdn = "https://fastly.jsdelivr.net/gh/siyuan-note/oceanpress@latest/apps/frontend/public/notebook/stage/protyle";
    const previewElement = document.getElementById("preview");

    Protyle.highlightRender(previewElement, cdn);
    Protyle.mathRender(previewElement, cdn, false);
    Protyle.mermaidRender(previewElement, cdn);
    Protyle.flowchartRender(previewElement, cdn);
    Protyle.graphvizRender(previewElement, cdn);
    Protyle.chartRender(previewElement, cdn);
    Protyle.mindmapRender(previewElement, cdn);
    Protyle.abcRender(previewElement, cdn);
    Protyle.htmlRender(previewElement);
    Protyle.plantumlRender(previewElement, cdn);
    document.querySelectorAll(".protyle-action__copy").forEach((item) => {
      item.addEventListener("click", (event) => {
        navigator.clipboard.writeText(
          item.parentElement.nextElementSibling.textContent.trimEnd(),
        );
        event.preventDefault();
        event.stopPropagation();
      });
    });
  </script>
  <footer style="margin-top: 30px; padding: 20px; background-color: #f8f9fa; text-align: center;">
  <p style="margin: 0;">
    技术支持：
    <a target="_blank" href="https://github.com/2234839/oceanPress_js" style="color: #007bff; text-decoration: none;">OceanPress</a> |
    <a target="_blank" href="https://heartstack.space/user/%E5%AD%90%E8%99%9A/posts" style="color: #007bff; text-decoration: none;">崮生（子虚）</a> |
    <a target="_blank" href="//beian.miit.gov.cn" style="color: #007bff; text-decoration: none;">湘ICP备18021783号-1</a>
  </p>
</footer>
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
<script type="text/javascript">
  docsearch({
    appId: "UBOM0V691R",
    apiKey: "0c572ae8b8611d29477570967f44c3cf",
    indexName: "shenzilong",
    insights: true, 
    container: '#search',
    debug: false
  });
</script>

</body>
</html>