# 2020/11 ((20201113135205-ji8ofpq "每日总结"))
{: id="20201117200356-pe2wphh"}

---

今天（2020/11/5）将文档改成了基于 ((20201105103725-dd01qas "思源笔记")) 实现的了，之后应该会提高在自己博客上写文章的频率了。
{: id="20201117200356-bhcolpv"}

之前都是在 我来 上写，毕竟那里的体验要好很多。但现在使用思源再实现双链之类的功能也很棒，虽然还比不上 我来 但终究还是很有必要在自己的平台输出的。
{: id="20201117200356-ijkil30"}

### 我的博客改为使用思源还有的一点小缺陷
{: id="20201117200356-svwjsgt"}

* {: id="20201117200356-sz185wm"}[X] ~~引用其他块的渲染还没写好（2020/11/8 号解决了）~~
* {: id="20201117200356-dvtpx9d"}[ ] 还有嵌入内容块的渲染需要实现
{: id="20201117200356-36hgi9y"}

## 加速度传感器与角速度传感器（陀螺仪）导致的窃听漏洞
{: id="20201117200356-ypyblu9"}

相关文章 https://www.leiphone.com/news/202002/rVLRlq5oqDFtIanl.html
{: id="20201117200356-9fg1404"}

现在最蛋疼的一点是在没有 root 的情况下好像没有办法禁用掉 app 对相关数据的获取。
{: id="20201117200356-3ubcd6d"}

根据 https://note.qidong.name/2018/03/hugo-mathjax/ 这篇文章给博客加上了 $s = pi * r^2$ 公式渲染的功能
{: id="20201117200356-suhpcln"}

lute 通过 `lute.SetHeadingAnchor(true);` 可以配置渲染 h 系列的标签的时候加入一个 a 标签链接到该标题 效果如图 ![image.png](assets/20201106140132-bml2b50-image.png)
{: id="20201117200356-pxm50vz"}

今天在使用 `const a ??= b` 这种语法的时候遇到了一些问题首先是没有添加 `"@babel/plugin-proposal-nullish-coalescing-operator"` 插件。
{: id="20201117200356-7qjkq8q"}

但添加之后还是报错 `Syntax Error: SyntaxError: This experimental syntax requires enabling the parser plugin: 'nullishCoalescingOperator' (123:21)` 这就很难受了， https://github.com/dcloudio/uni-app/issues/1660 这里有和我一样踩坑的人。但还没有找到合适的解决方案，只能在 uni-app 项目中先放弃使用该语法了
{: id="20201117200356-n9db6uh"}

## js 让一段实际上是异步的代码写起来像是同步的
{: id="20201117200356-plhigaa"}

https://lihautan.com/pause-and-resume-a-javascript-function/
{: id="20201117200356-t5t06xg"}

这篇文章的主要思路其实就是 第一次 执行代码遇到异步点的时候执行异步函数然后 throw 中断下面的代码，然后拿到结果后再执行一次。
{: id="20201117200356-4gjxaba"}

这个体验还是不太行的实现起来也太复杂
{: id="20201117200356-t25kkxs"}

我在知乎提了一个问题 https://www.zhihu.com/question/429221892
{: id="20201117200356-xv4kssb"}

`xml:base="https://shenzilong.cn/关于/赞助.html"` 这样的属性可以设置 XML 的 base 路径，今天给我的 [feed](/blog/feed) 加上了这样的路径 ，但不知道是不是我使用的 rss 阅读器的问题，他好像还是没有办法正确识别。
{: id="20201117200356-mydgqf2"}

例如 `<a href="#标题1">`  这样的路径他会识别为 `https://shenzilong.cn/关于/赞助#标题1`  这样的路径。
{: id="20201117200356-0idqk4p"}

## 一个简简单单的 TypeScript RPC 解决方案
{: id="20201117200356-j1oc6i5"}

> 有时候不需要什么「分布式」，前后端「项目分离」。
> {: id="20201117200356-9vbe10q"}
>
> 只是想可以方便调用一个接口、不去写接口文档、还有有完善的方法类型提示而已。
> {: id="20201117200356-pct4g90"}
>
> 何必那么复杂呢。......
> {: id="20201117200356-zgz8umh"}
>
> 这里提供超轻量级的远程调用，完备的类型提示！
> {: id="20201117200356-w77acj0"}
{: id="20201117200356-imxopr6"}

[codesandbox 体验地址](https://codesandbox.io/s/github/2234839/typescript_RPC_demo?utm_medium=plugin&file=/src/rpc.ts) codesandbox 的类型提示还不太行，本地开发是没有问题的
{: id="20201117200356-5i04tq8"}

[demo  github 地址](https://github.com/2234839/typescript_RPC_demo)
{: id="20201117200356-bapzjfn"}

![image.png](assets/20201109143728-hfw4r7v-image.png)
{: id="20201117200356-my0h0ig"}

#### 0x00 服务端方法
{: id="20201117200356-7lu5495"}

```typescript
// apis/time.ts
export function currentTime() {
  return Date.now();
}

export function currentTime2(toLocaleString: boolean) {
  if (toLocaleString) {
    return new Date().toLocaleString();
  } else {
    return Date.now();
  }
}
```
{: id="20201117200356-w6ql3cg"}

这里随便写了几个方法
{: id="20201117200356-6our10x"}

#### 0x01 聚合
{: id="20201117200356-gke4gqm"}

```typescript
// apis/index.ts
export * from "./time";
```
{: id="20201117200356-uuecfdh"}

约定俗称的用一个 `index.ts` 文件将其他文件中的方法聚合起来。
{: id="20201117200356-se18tcg"}

#### 0x02 Remote Procedure Call !
{: id="20201117200356-75w0vsv"}

Remote Procedure Call 要说的高大上呢那也有很多可以做的细节，但我们追求简简单单。
{: id="20201117200356-k247r6k"}

```typescript
// router/rpc.ts
import * as apis from "../apis";

export async function post(req: any, res: any) {
  const data = [] as any[];
  req.on("data", function (chunk) {
    data.push(chunk);
  });
  req.on("end", async () => {
    const { method, data: _data } = JSON.parse(data.join(""));
    const result = await apis[method](..._data);
    res.writeHead(200, {
      "Content-Type": "application/json"
    });
    res.end(JSON.stringify(result));
  });
}
```
{: id="20201117200356-rcq2n1t"}

简单的远程调用只需要暴露一个接口让用户可以调用本机方法就行了
{: id="20201117200356-1xh64jb"}

#### 0x03 TypeScript ! 🎉
{: id="20201117200356-uw1jygm"}

```typescript
//  rpc.ts 
/** ═════════🏳‍🌈 超轻量级的远程调用，完备的类型提示！ 🏳‍🌈═════════  */
import type * as apis from "./apis";
type apis = typeof apis;
type method = keyof apis;

/** Remote call ， 会就近的选择是远程调用还是使用本地函数 */
export function RC<K extends method>(
  method: K,
  data: Parameters<apis[K]>
): Promise<unPromise<ReturnType<apis[K]>>> {
  if (typeof window !== "undefined") {
    // 客户端运行
    return fetch("/rpc", {
      method: "POST",
      body: JSON.stringify({ method, data }),
      headers: {
        "content-type": "application/json"
      }
    }).then((r) => r.json());
  } else {
    // 服务端运行，使用 import 的原因是避免 apis 的代码被打包发送到客户端
    return import("./apis/index").then(async (r: any) => {
      return await r[method](...data);
    });
  }
}

/** 解开 promise 类型包装 */
declare type unPromise<T> = T extends Promise<infer R> ? R : T;

// 示例 1 直接使用 RC

RC("currentTime", []).then((r) => console.log("服务器当前时间", r));
RC("currentTime2", [true]).then((r) => console.log("服务器当前时间本地化", r));

/** 包装了一次的 RC 方便跳转到函数定义  */
export const API = new Proxy(
  {},
  {
    get(target, p: method) {
      return (...arg: any) => RC(p, arg);
    }
  }
) as apisPromiseify;

/** apis 中包含的方法可能不是返回 promise 的，但 RC 调用后的一定是返回 promsie */
type apisPromiseify = {
  readonly [K in keyof apis]: (
    ...arg: Parameters<apis[K]>
  ) => Promise<unPromise<ReturnType<apis[K]>>>;
};

// 示例 2 通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处

API.currentTime().then((r) => console.log("服务器当前时间", r));
API.currentTime2(true).then((r) => console.log("服务器当前时间本地化", r));

```
{: id="20201117200356-4bdhkjw"}

上面就是一顿类型操作，打完收工。
{: id="20201117200356-00yjzss"}

接下来无论是在服务端还是客户端通过 RC 或 API 来调用方法获得的体验是一模一样的。
{: id="20201117200356-keho9wv"}

并且通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处。啥类型提示都有，接口文档也没有必要了。
{: id="20201117200356-hmh8nyd"}

#### 总结
{: id="20201117200356-mo0u89w"}

这个~~项目~~ 方法 的重点在于复用了服务端提供接口的类型，并且可以直接跳转过去。
{: id="20201117200356-9ii0ln8"}

追求简单的方法，完善类型体验。
{: id="20201117200356-njv18ea"}

我写出这个想法之后觉得我以前就是憨憨，自己写一个项目还维护一份接口文档 😀。
{: id="20201117200356-fts4y9p"}

---

现在 codesandbox 还不支持中文文件名，坑了我一把
{: id="20201117200356-d3a8elg"}

![image.png](assets/20201109171018-un3fain-image.png)
{: id="20201117200356-tgkz7kq"}

## 2020-11-13
{: id="20201117200356-4uady63"}

### 数组求和
{: id="20201113135603-vp1h5po"}

```typescript
/** 数组求和 */
export function ArraySum<T>(arr: T[], f: (el: T) => number) {
  return arr.map(f).reduce((a, b) => a + b, 0);
}
```
{: id="20201117200356-sp6g69f"}

### 数组去重 ＆ 求和
{: id="20201113135603-t17a0wt"}

```typescript
/** 数组去重
 * 1. 可以设置函数来决定什么样算重复
 * 2. 可以设置函数来决定遇到重复的结果该怎么合并
 */
export function Array去重<T>(
  arr: T[],
  /** 需要返回该对象的一个唯一标识（需要是原始值 用于和其他的进行比较） */ f: (el: T) => unknown = (el: T) => el,
  /** 用于决定和重复对象的合并方式，默认取后面的值，丢弃旧值 */ mergeF: (a: T, b: T) => T = (a, b) => b,
) {
  let result = [] as T[];
  let label = [] as unknown[];

  for (const el of arr) {
    const id = f(el);
    const i = label.findIndex((el) => el === id);
    if (i !== -1) {
      result[i] = mergeF(result[i], el);
    } else {
      label.push(id);
      result.push(el);
    }
  }

  return result;
}

```
{: id="20201117200356-5ogkjvr"}

### 数组取随机 n 个元素
{: id="20201113135603-ohicvju"}

```typescript
/** 从数组中随机取 n 个元素 */
export function sampleSize<T>([...arr]: T[], n = 1) {
  let m = arr.length;
  while (m) {
    const i = Math.floor(Math.random() * m--);
    [arr[m], arr[i]] = [arr[i], arr[m]];
  }
  return arr.slice(0, n);
}
```
{: id="20201117200356-9wuwl8n"}

---

今天（2020-11-17）发现 GitHub 的消息那里的分页也是存在问题的，就是在一开始如果有两页数据一直点已读然后点下一页发现是空的，再点上一页才能看见消息
{: id="20201117200356-gjdde9o"}

---

## 使用编辑距离算法为自己的博客生成 404 页面的导流推荐
{: id="20201117200356-jzs61ke"}

例如本文正确地址  [https://shenzilong.cn/record/每日总结/2020/11月.html](https://shenzilong.cn/record/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/2020/11%E2%80%B8%E6%9C%88.html)  ，如果用户输入错了写成了  [https://shenzilong.cn/record/每日总结2020/11月.html](https://shenzilong.cn/record/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93%E2%80%B82020/11%E6%9C%88.html)  （每日总结后面少了个 「/」）
{: id="20201117200356-38ce6cr"}

![image.png](assets/20201117100730-7in4b2o-image.png)
{: id="20201117200356-t4w0soh"}

咱依旧能如图中这般推荐给用户他可能想要访问的地址 😀
{: id="20201117200356-tgs7rry"}

### 编辑距离算法
{: id="20201117200356-e83ey67"}

```typescript
/** 求两个数组的编辑距离 */
export function minDistance<T>(l1: T[], l2: T[], equal?: (i1: number, i2: number) => boolean): number {
  if (equal === undefined) {
    /** 比较对应位置的元素是否相等 */
    return minDistance(l1, l2, (i1, i2) => l1[i1] === l2[i2]);
  }
  const len1 = l1.length;
  const len2 = l2.length;

  let matrix = [] as any;

  for (let i = 0; i <= len1; i++) {
    // 构造二维数组
    matrix[i] = [];
    for (let j = 0; j <= len2; j++) {
      // 初始化
      if (i == 0) {
        matrix[i][j] = j;
      } else if (j == 0) {
        matrix[i][j] = i;
      } else {
        // 进行最小值分析
        let cost = 0;
        if (!equal(i - 1, j - 1)) {
          // 相同为0，不同置1
          cost = 1;
        }
        const temp = matrix[i - 1][j - 1] + cost;

        matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, temp);
      }
    }
  }
  return matrix[len1][len2]; //返回右下角的值
}

```
{: id="20201117200356-te73dvi"}

作为调包侠的我只要知道 `minDistance` 可以只传入两数组，他就返回一个数值表示这两数组之间的差异，数值越大差异越大就可以了
{: id="20201117200356-wgn0dky"}

然后就是获取全站链接与用户输入地址一一比较返回差异最小的五个给用户查看
{: id="20201117200356-ijjqhwe"}

---

## 鸽子漫步表情包
{: id="20201117144207-xqseawh" bookmark="表情包"}

![漫步鸽.gif](assets/20201117144233-sle91fx-漫步鸽.gif)
{: id="20201117200356-dmciruq"}

---

{: id="20201119180137-4u37ru3"}

今天（2020/11/19）开始使用 go 写一个 [https://github.com/2234839/md2website](https://github.com/2234839/md2website) 从 markdown 生成静态站点的工具，现写现学竟也写出了一个简单的转换工具了。
{: id="20201119180137-ju6n04y"}

目前的体验是感觉 ts 的那种类型设计才是最爽的，go 的类型系统还是没有那么舒服。
{: id="20201119180341-ze8ma2y"}

---

{: id="20201120112441-f8m1e07"}

> 我们就当做无事发生过/
> {: id="20201120112442-1sg0o16"}
{: id="20201120112441-ocetbyn"}

突然觉得这句话很带感
{: id="20201120112500-66fngen"}

{: id="20201119180432-t9ktg61"}
