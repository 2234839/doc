# 2020/11 ((20201113135205-ji8ofpq "每日总结"))
{: id="20201116135016-bad94cm"}

---

今天（2020/11/5）将文档改成了基于 ((20201105103725-dd01qas "思源笔记")) 实现的了，之后应该会提高在自己博客上写文章的频率了。
{: id="20201116135016-952pv8a"}

之前都是在 我来 上写，毕竟那里的体验要好很多。但现在使用思源再实现双链之类的功能也很棒，虽然还比不上 我来 但终究还是很有必要在自己的平台输出的。
{: id="20201116135016-zckebv7"}

### 我的博客改为使用思源还有的一点小缺陷
{: id="20201116135016-592oam1"}

* {: id="20201116135016-mlb07n9"}[X] ~~引用其他块的渲染还没写好（2020/11/8 号解决了）~~
* {: id="20201116135016-rbh2bhz"}[ ] 还有嵌入内容块的渲染需要实现
{: id="20201116135016-nkqm4ct"}

## 加速度传感器与角速度传感器（陀螺仪）导致的窃听漏洞
{: id="20201116135016-7ucvls7"}

相关文章 https://www.leiphone.com/news/202002/rVLRlq5oqDFtIanl.html
{: id="20201116135016-y9r0kdi"}

现在最蛋疼的一点是在没有 root 的情况下好像没有办法禁用掉 app 对相关数据的获取。
{: id="20201116135016-gnutlls"}

根据 https://note.qidong.name/2018/03/hugo-mathjax/ 这篇文章给博客加上了 $s = pi * r^2$ 公式渲染的功能
{: id="20201116135016-10nlusf"}

lute 通过 `lute.SetHeadingAnchor(true);` 可以配置渲染 h 系列的标签的时候加入一个 a 标签链接到该标题 效果如图 ![image.png](assets/20201106140132-bml2b50-image.png)
{: id="20201116135016-jlnocbi"}

今天在使用 `const a ??= b` 这种语法的时候遇到了一些问题首先是没有添加 `"@babel/plugin-proposal-nullish-coalescing-operator"` 插件。
{: id="20201116135016-72bhuz1"}

但添加之后还是报错 `Syntax Error: SyntaxError: This experimental syntax requires enabling the parser plugin: 'nullishCoalescingOperator' (123:21)` 这就很难受了， https://github.com/dcloudio/uni-app/issues/1660 这里有和我一样踩坑的人。但还没有找到合适的解决方案，只能在 uni-app 项目中先放弃使用该语法了
{: id="20201116135016-6la1whi"}

## js 让一段实际上是异步的代码写起来像是同步的
{: id="20201116135016-8m0hkwc"}

https://lihautan.com/pause-and-resume-a-javascript-function/
{: id="20201116135016-491060a"}

这篇文章的主要思路其实就是 第一次 执行代码遇到异步点的时候执行异步函数然后 throw 中断下面的代码，然后拿到结果后再执行一次。
{: id="20201116135016-kqbooia"}

这个体验还是不太行的实现起来也太复杂
{: id="20201116135016-vce3pet"}

我在知乎提了一个问题 https://www.zhihu.com/question/429221892
{: id="20201116135016-o5gk1q7"}

`xml:base="https://shenzilong.cn/关于/赞助.html"` 这样的属性可以设置 XML 的 base 路径，今天给我的 [feed](/blog/feed) 加上了这样的路径 ，但不知道是不是我使用的 rss 阅读器的问题，他好像还是没有办法正确识别。
{: id="20201116135016-fbkn5nh"}

例如 `<a href="#标题1">`  这样的路径他会识别为 `https://shenzilong.cn/关于/赞助#标题1`  这样的路径。
{: id="20201116135016-98gv251"}

## 一个简简单单的 TypeScript RPC 解决方案
{: id="20201116135016-koagufs"}

> 有时候不需要什么「分布式」，前后端「项目分离」。
> {: id="20201116135016-e9fsnsu"}
>
> 只是想可以方便调用一个接口、不去写接口文档、还有有完善的方法类型提示而已。
> {: id="20201116135016-vonov1p"}
>
> 何必那么复杂呢。......
> {: id="20201116135016-g7jbysg"}
>
> 这里提供超轻量级的远程调用，完备的类型提示！
> {: id="20201116135016-rt65pci"}
{: id="20201116135016-k5pb1pr"}

[codesandbox 体验地址](https://codesandbox.io/s/github/2234839/typescript_RPC_demo?utm_medium=plugin&file=/src/rpc.ts) codesandbox 的类型提示还不太行，本地开发是没有问题的
{: id="20201116135016-i39j23y"}

[demo  github 地址](https://github.com/2234839/typescript_RPC_demo)
{: id="20201116135016-bbxisjv"}

![image.png](assets/20201109143728-hfw4r7v-image.png)
{: id="20201116135016-z3lr2au"}

#### 0x00 服务端方法
{: id="20201116135016-vfft252"}

```typescript
// apis/time.ts
export function currentTime() {
  return Date.now();
}

export function currentTime2(toLocaleString: boolean) {
  if (toLocaleString) {
    return new Date().toLocaleString();
  } else {
    return Date.now();
  }
}
```
{: id="20201116135016-dh844ap"}

这里随便写了几个方法
{: id="20201116135016-ifsiklt"}

#### 0x01 聚合
{: id="20201116135016-k33h2hz"}

```typescript
// apis/index.ts
export * from "./time";
```
{: id="20201116135016-oo9kv7u"}

约定俗称的用一个 `index.ts` 文件将其他文件中的方法聚合起来。
{: id="20201116135016-h2ozrko"}

#### 0x02 Remote Procedure Call !
{: id="20201116135016-s8wzw2n"}

Remote Procedure Call 要说的高大上呢那也有很多可以做的细节，但我们追求简简单单。
{: id="20201116135016-sr3foxp"}

```typescript
// router/rpc.ts
import * as apis from "../apis";

export async function post(req: any, res: any) {
  const data = [] as any[];
  req.on("data", function (chunk) {
    data.push(chunk);
  });
  req.on("end", async () => {
    const { method, data: _data } = JSON.parse(data.join(""));
    const result = await apis[method](..._data);
    res.writeHead(200, {
      "Content-Type": "application/json"
    });
    res.end(JSON.stringify(result));
  });
}
```
{: id="20201116135016-6n7aoze"}

简单的远程调用只需要暴露一个接口让用户可以调用本机方法就行了
{: id="20201116135016-bp4307n"}

#### 0x03 TypeScript ! 🎉
{: id="20201116135016-p693l4m"}

```typescript
//  rpc.ts 
/** ═════════🏳‍🌈 超轻量级的远程调用，完备的类型提示！ 🏳‍🌈═════════  */
import type * as apis from "./apis";
type apis = typeof apis;
type method = keyof apis;

/** Remote call ， 会就近的选择是远程调用还是使用本地函数 */
export function RC<K extends method>(
  method: K,
  data: Parameters<apis[K]>
): Promise<unPromise<ReturnType<apis[K]>>> {
  if (typeof window !== "undefined") {
    // 客户端运行
    return fetch("/rpc", {
      method: "POST",
      body: JSON.stringify({ method, data }),
      headers: {
        "content-type": "application/json"
      }
    }).then((r) => r.json());
  } else {
    // 服务端运行，使用 import 的原因是避免 apis 的代码被打包发送到客户端
    return import("./apis/index").then(async (r: any) => {
      return await r[method](...data);
    });
  }
}

/** 解开 promise 类型包装 */
declare type unPromise<T> = T extends Promise<infer R> ? R : T;

// 示例 1 直接使用 RC

RC("currentTime", []).then((r) => console.log("服务器当前时间", r));
RC("currentTime2", [true]).then((r) => console.log("服务器当前时间本地化", r));

/** 包装了一次的 RC 方便跳转到函数定义  */
export const API = new Proxy(
  {},
  {
    get(target, p: method) {
      return (...arg: any) => RC(p, arg);
    }
  }
) as apisPromiseify;

/** apis 中包含的方法可能不是返回 promise 的，但 RC 调用后的一定是返回 promsie */
type apisPromiseify = {
  readonly [K in keyof apis]: (
    ...arg: Parameters<apis[K]>
  ) => Promise<unPromise<ReturnType<apis[K]>>>;
};

// 示例 2 通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处

API.currentTime().then((r) => console.log("服务器当前时间", r));
API.currentTime2(true).then((r) => console.log("服务器当前时间本地化", r));

```
{: id="20201116135016-h3tvqd6"}

上面就是一顿类型操作，打完收工。
{: id="20201116135016-p9nqpav"}

接下来无论是在服务端还是客户端通过 RC 或 API 来调用方法获得的体验是一模一样的。
{: id="20201116135016-wisxp20"}

并且通过 API 对象调用对应方法，这里的优点是可以直接跳转到对应函数的源码处。啥类型提示都有，接口文档也没有必要了。
{: id="20201116135016-wzyawym"}

#### 总结
{: id="20201116135016-7wgaw6k"}

这个~~项目~~ 方法 的重点在于复用了服务端提供接口的类型，并且可以直接跳转过去。
{: id="20201116135016-yejf1yq"}

追求简单的方法，完善类型体验。
{: id="20201116135016-i06meff"}

我写出这个想法之后觉得我以前就是憨憨，自己写一个项目还维护一份接口文档 😀。
{: id="20201116135016-242a44k"}

---

现在 codesandbox 还不支持中文文件名，坑了我一把
{: id="20201116135016-atjpgdw"}

![image.png](assets/20201109171018-un3fain-image.png)
{: id="20201116135016-bdcg9jc"}

## 2020-11-13
{: id="20201116135016-7dgbilh"}

### 数组求和
{: id="20201113135603-vp1h5po"}

```typescript
/** 数组求和 */
export function ArraySum<T>(arr: T[], f: (el: T) => number) {
  return arr.map(f).reduce((a, b) => a + b, 0);
}
```
{: id="20201116135016-mu3t9nv"}

### 数组去重 ＆ 求和
{: id="20201113135603-t17a0wt"}

```typescript
/** 数组去重
 * 1. 可以设置函数来决定什么样算重复
 * 2. 可以设置函数来决定遇到重复的结果该怎么合并
 */
export function Array去重<T>(
  arr: T[],
  /** 需要返回该对象的一个唯一标识（需要是原始值 用于和其他的进行比较） */ f: (el: T) => unknown = (el: T) => el,
  /** 用于决定和重复对象的合并方式，默认取后面的值，丢弃旧值 */ mergeF: (a: T, b: T) => T = (a, b) => b,
) {
  let result = [] as T[];
  let label = [] as unknown[];

  for (const el of arr) {
    const id = f(el);
    const i = label.findIndex((el) => el === id);
    if (i !== -1) {
      result[i] = mergeF(result[i], el);
    } else {
      label.push(id);
      result.push(el);
    }
  }

  return result;
}

```
{: id="20201116135016-1g2gvn0"}

### 数组取随机 n 个元素
{: id="20201113135603-ohicvju"}

```typescript
/** 从数组中随机取 n 个元素 */
export function sampleSize<T>([...arr]: T[], n = 1) {
  let m = arr.length;
  while (m) {
    const i = Math.floor(Math.random() * m--);
    [arr[m], arr[i]] = [arr[i], arr[m]];
  }
  return arr.slice(0, n);
}
```
{: id="20201116135016-2byjhac"}

---

{: id="20201117095736-9okmqas"}

今天（2020-11-17）发现 github 的消息那里的分页也是存在问题的，就是在一开始如果有两页数据一直点已读然后点下一页发现是空的，再点上一页才能看见消息
{: id="20201117095736-yjipaoi"}
